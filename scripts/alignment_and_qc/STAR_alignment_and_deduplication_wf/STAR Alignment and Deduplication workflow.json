{
  "outputs": [
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "sbg:x": 1134.5831298828125,
      "source": [
        "#STAR.log_files"
      ],
      "required": false,
      "id": "#chimeric_alignments",
      "sbg:y": 295.24993896484375,
      "label": "STAR_Logs"
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        "File"
      ],
      "sbg:x": 1349,
      "source": [
        "#Picard_MarkDuplicates.metrics_file"
      ],
      "required": false,
      "id": "#metrics_file",
      "sbg:y": 427.99652099609375,
      "label": "metrics_file"
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        {
          "items": "File",
          "name": "summary",
          "type": "array"
        }
      ],
      "sbg:x": 966,
      "source": [
        "#SBG_Flatten_1.flat"
      ],
      "required": false,
      "id": "#summary",
      "sbg:y": 13.99716192483902,
      "label": "summary"
    },
    {
      "sbg:includeInPorts": true,
      "type": [
        "null",
        {
          "items": "File",
          "name": "deduped_bam_and_bai",
          "type": "array"
        }
      ],
      "sbg:x": 1337,
      "source": [
        "#Picard_MarkDuplicates.deduped_bam_and_bai"
      ],
      "required": false,
      "id": "#deduped_bam_and_bai",
      "sbg:y": 608.9971923828125,
      "label": "deduped bam with index"
    }
  ],
  "sbg:image_url": "https://brood.sbgenomics.com/static/sarah/rd168-chern-wtx-align-and-qc/rna-seq-alignment-star/3.png",
  "sbg:canvas_x": 193,
  "sbg:canvas_y": 53,
  "inputs": [
    {
      "id": "#sjdbGTFfile",
      "type": [
        "null",
        {
          "items": "File",
          "type": "array"
        }
      ],
      "label": "sjdbGTFfile",
      "sbg:y": 615.0833129882812,
      "sbg:x": -42.5
    },
    {
      "id": "#adapters",
      "type": [
        "null",
        "File"
      ],
      "sbg:x": -102,
      "sbg:y": 417.9971618652344,
      "sbg:fileTypes": "FASTA, FA",
      "label": "adapters"
    },
    {
      "id": "#reads",
      "type": [
        {
          "items": "File",
          "name": "reads",
          "type": "array"
        }
      ],
      "sbg:x": -180,
      "batchType": "metadata.sample_id",
      "sbg:y": 196.99716186523438,
      "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
      "label": "reads"
    },
    {
      "id": "#genome",
      "type": [
        "File"
      ],
      "sbg:x": 117,
      "sbg:y": 762.9971923828125,
      "sbg:fileTypes": "TAR",
      "label": "genome generate tar file"
    },
    {
      "type": [
        "null",
        "int"
      ],
      "label": "Memory per job",
      "sbg:suggestedValue": 12000,
      "sbg:toolDefaultValue": "2048",
      "id": "#memory_per_job",
      "description": "Amount of RAM memory to be used per job. Defaults to 2048MB for single threaded jobs."
    }
  ],
  "sbg:revisionsInfo": [
    {
      "sbg:revision": 0,
      "sbg:modifiedBy": "sarah",
      "sbg:revisionNotes": "Copy of sarah/rd168-chern-newtests/rna-seq-alignment-star/47",
      "sbg:modifiedOn": 1471538983
    },
    {
      "sbg:revision": 1,
      "sbg:modifiedBy": "sarah",
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1471539086
    },
    {
      "sbg:revision": 2,
      "sbg:modifiedBy": "sarah",
      "sbg:revisionNotes": "Added cufflinks",
      "sbg:modifiedOn": 1472173685
    },
    {
      "sbg:revision": 3,
      "sbg:modifiedBy": "sarah",
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472219720
    }
  ],
  "hints": [
    {
      "value": "c3.8xlarge",
      "class": "sbg:AWSInstanceType"
    }
  ],
  "description": "Alignment to a reference genome and transcriptome presents the first step of RNA-Seq analysis. This pipeline uses STAR, an ultrafast RNA-seq aligner capable of mapping full length RNA sequences and detecting de novo canonical junctions, non-canonical splices, and chimeric (fusion) transcripts. It is optimized for mammalian sequence reads, but fine tuning of its parameters enables customization to satisfy unique needs.\n\nSTAR accepts one file per sample (or two files for paired-end data).  \nSplice junction annotations can optionally be collected from splice junction databases. Set the \"Overhang length\" parameter to a value larger than zero in order to use splice junction databases. For constant read length, this value should (ideally) be equal to mate length decreased by 1; for long reads with non-constant length, this value should be 100 (pipeline default). \nFastQC Analysis on FASTQ files reveals read length distribution. STAR can detect chimeric transcripts, but parameter \"Min segment length\" in \"Chimeric Alignments\" category must be adjusted to a desired minimum chimeric segment length. Aligned reads are reported in BAM format and can be viewed in a genome browser (such as IGV). A file containing detected splice junctions is also produced.\n\nUnmapped reads are reported in FASTQ format and can be included in an output BAM file. The \"Output unmapped reads\" and \"Write unmapped in SAM\" parameters enable unmapped output type selection.",
  "sbg:toolAuthor": "Seven Bridges Genomics",
  "id": "https://api.sbgenomics.com/v2/apps/sarah/rd168-chern-wtx-align-and-qc/rna-seq-alignment-star/3/raw/",
  "sbg:license": "Apache License 2.0",
  "sbg:createdBy": "sarah",
  "label": "01 STAR Alignment and Deduplication_batch",
  "sbg:toolkitVersion": "2.4.2a",
  "sbg:validationErrors": [],
  "sbg:batchBy": {
    "criteria": [
      "metadata.sample_id"
    ],
    "type": "criteria"
  },
  "sbg:batchInput": "#reads",
  "steps": [
    {
      "outputs": [
        {
          "id": "#SBG_Flatten.flat"
        }
      ],
      "sbg:x": 515,
      "run": {
        "sbg:cmdPreview": "python /opt/sbg-flatten.py",
        "outputs": [
          {
            "id": "#flat",
            "outputBinding": {
              "sbg:metadata": {}
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "All grouped files",
            "description": "All grouped files as one list."
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:id": "sarah/rd168-chern-newtests/sbg-flatten/0",
        "inputs": [
          {
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "required": true,
            "label": "Nested",
            "description": "Files from all SBG Group Input outputs should be provided.",
            "id": "#nested",
            "sbg:category": "Input files"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/sbg-flatten/1",
            "sbg:modifiedOn": 1470418538
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/ana_d/sbg-flatten:1.0",
            "class": "DockerRequirement",
            "dockerImageId": "c0e1d93b3d76"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          }
        ],
        "description": "SBG Flatten is used only with SBG Group Input app for purposes of providing grouped inputs. All SBG Group Input outputs should be passed to the \"Nested\" SBG Flatten input in order to produce the output with all grouped files as one list.",
        "requirements": [],
        "id": "sarah/rd168-chern-newtests/sbg-flatten/0",
        "sbg:license": "Apache License 2.0",
        "arguments": [],
        "stdout": "",
        "sbg:copyOf": "admin/sbg-public-data/sbg-flatten/1",
        "sbg:validationErrors": [],
        "sbg:toolkit": "SBGTools",
        "sbg:createdOn": 1470418538,
        "baseCommand": [
          "python",
          "/opt/sbg-flatten.py"
        ],
        "sbg:toolkitVersion": "1.0",
        "stdin": "",
        "sbg:toolAuthor": "Ana Damljanovic/ Seven Bridges Genomics",
        "sbg:project": "sarah/rd168-chern-newtests",
        "sbg:modifiedBy": "dave",
        "class": "CommandLineTool",
        "sbg:revisionNotes": "Copy of admin/sbg-public-data/sbg-flatten/1",
        "sbg:sbgMaintained": false,
        "appUrl": "/u/sarah/rd168-chern-newtests/apps/#sarah/rd168-chern-newtests/sbg-flatten/0",
        "x": 515,
        "sbg:job": {
          "inputs": {
            "nested": "nested"
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 0,
        "sbg:contributors": [
          "dave"
        ],
        "sbg:revision": 0,
        "sbg:createdBy": "dave",
        "y": 276.65625,
        "sbg:modifiedOn": 1470418538,
        "label": "SBG Flatten",
        "sbg:categories": [
          "Other"
        ]
      },
      "inputs": [
        {
          "source": [
            "#Eautils_Fastq_mcf.filtered_reads"
          ],
          "id": "#SBG_Flatten.nested"
        }
      ],
      "id": "#SBG_Flatten",
      "sbg:y": 276.65625
    },
    {
      "outputs": [
        {
          "id": "#Picard_MarkDuplicates.metrics_file"
        },
        {
          "id": "#Picard_MarkDuplicates.deduped_bam_and_bai"
        }
      ],
      "sbg:x": 1027,
      "run": {
        "sbg:cmdPreview": "java -Xmx2048M -jar /opt/picard-tools-1.140/picard.jar MarkDuplicates INPUT=input_bam.ext METRICS_FILE=input_bam.metrics OUTPUT=input_bam.deduped.bam",
        "outputs": [
          {
            "id": "#metrics_file",
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "input_bam"
              },
              "glob": "*.metrics",
              "sbg:inheritMetadataFrom": "#input_bam"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "File to which the duplication metrics will be written.",
            "sbg:fileTypes": "METRICS",
            "label": "Metrics file"
          },
          {
            "id": "#deduped_bam_and_bai",
            "outputBinding": {
              "sbg:metadata": {
                "__inherit__": "input_bam"
              },
              "glob": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "\"*.{bam,bai}\""
              },
              "sbg:inheritMetadataFrom": "#input_bam"
            },
            "type": [
              "null",
              {
                "items": "File",
                "name": "deduped_bam_and_bai",
                "type": "array"
              }
            ],
            "description": "The output file to which marked records will be written.",
            "sbg:fileTypes": "BAM, SAM",
            "label": "Deduped BAM"
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:id": "sarah/rd168-chern-newtests/picard-markduplicates-1-140/3",
        "inputs": [
          {
            "type": [
              "null",
              {
                "symbols": [
                  "ERROR",
                  "WARNING",
                  "INFO",
                  "DEBUG"
                ],
                "name": "verbosity",
                "type": "enum"
              }
            ],
            "label": "Verbosity",
            "inputBinding": {
              "position": 6,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "VERBOSITY="
            },
            "sbg:toolDefaultValue": "INFO",
            "description": "Control verbosity of logging. Default value: INFO. This option can be set to 'null' to clear the default value. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
            "id": "#verbosity",
            "sbg:category": ""
          },
          {
            "id": "#validation_stringency",
            "label": "Validation stringency",
            "inputBinding": {
              "position": 4,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  if ($job.inputs.validation_stringency)\n  {\n    return $job.inputs.validation_stringency\n  }\n  else\n  {\n    return \"SILENT\"\n  }\n}"
              },
              "sbg:cmdInclude": true,
              "prefix": "VALIDATION_STRINGENCY=",
              "separate": false
            },
            "sbg:toolDefaultValue": "SILENT",
            "type": [
              "null",
              {
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "name": "validation_stringency",
                "type": "enum"
              }
            ],
            "description": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}."
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Sorting collections size ratio",
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "SORTING_COLLECTION_SIZE_RATIO="
            },
            "sbg:toolDefaultValue": "0.25",
            "description": "This number, plus the maximum RAM available to the JVM, determine the memory footprint used by some of the sorting collections. If you are running out of memory, try reducing this number.",
            "id": "#sorting_collections_size_ratio",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "remove_duplicates",
                "type": "enum"
              }
            ],
            "label": "Remove duplicates",
            "inputBinding": {
              "position": 3,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "REMOVE_DUPLICATES="
            },
            "sbg:toolDefaultValue": "false",
            "description": "If this parameter is set to true, duplicates will be written to the output file. If set to false, duplicates will be written with the appropriate flags set. Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "id": "#remove_duplicates",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              "string"
            ],
            "label": "Read name regex",
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "READ_NAME_REGEX="
            },
            "sbg:toolDefaultValue": "[a-zA-Z0-9]+:[0-9]:([0-9]+):([0-9]+):([0-9]+).*",
            "description": "Regular expression that can be used to parse read names in the incoming SAM file. Read names are parsed to extract three variables: tile/region, x coordinate and y coordinate. These values are used to estimate the rate of optical duplication in order to give a more accurate estimated library size. Set this option to null to disable optical duplicate detection. The regular expression should contain three capture groups for the three variables, in order. It must match the entire read name. Note that if the default regex is specified, a regex match is not actually done, but instead the read name is split on colon character. For 5 element names, the 3rd, 4th and 5th elements are assumed to be tile, x and y values, respectively. For 7 element names (CASAVA 1.8), the 5th, 6th, and 7th elements are assumed to be tile, x and y values, respectively. Default value: [a-zA-Z0-9]+:[0-9]:([0-9]+):([0-9]+):([0-9]+).*. This option can be set to 'null' to clear the default value.",
            "id": "#read_name_regex",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "name": "quiet",
                "type": "enum"
              }
            ],
            "label": "Quiet",
            "inputBinding": {
              "position": 4,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "QUIET="
            },
            "sbg:toolDefaultValue": "False",
            "description": "This parameter indicates whether to suppress job-summary info on System.err. Possible values: {True, False}.",
            "id": "#quiet",
            "sbg:category": ""
          },
          {
            "sbg:altPrefix": "PG",
            "id": "#program_record",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "position": 10,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "PROGRAM_RECORD_ID="
            },
            "sbg:toolDefaultValue": "MarkDuplicates",
            "description": "The program record ID for the @PG record(s) created by this program. Set to null to disable PG record creation. This string may have a suffix appended to avoid collision with other program record IDs. Default value: MarkDuplicates. This option can be set to 'null' to clear the default value.",
            "label": "Program record ID",
            "sbg:category": ""
          },
          {
            "id": "#program_group_ver",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "PROGRAM_GROUP_VERSION="
            },
            "sbg:altPrefix": "PG_VERSION=",
            "description": "Value of version number (VN) tag of program group (PG) record to be created. If not specified, the version will be detected automatically. Default value: null.",
            "label": "Program group version",
            "sbg:category": ""
          },
          {
            "sbg:altPrefix": "PG_NAME=",
            "id": "#program_group_name",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "PROGRAM_GROUP_NAME="
            },
            "sbg:toolDefaultValue": "MarkDuplicates",
            "description": "Value of program name (PN) tag of program group (PG) record to be created. Default value: MarkDuplicates. This option can be set to 'null' to clear the default value.",
            "label": "Program group name",
            "sbg:category": ""
          },
          {
            "sbg:altPrefix": "PG_COMMAND=",
            "id": "#program_group_command_line",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "PROGRAM_GROUP_COMMAND_LINE="
            },
            "sbg:toolDefaultValue": "null",
            "description": "Value of command line (CL) tag of program group (PG) record to be created. If not supplied the command line will be detected automatically. Default value: null.",
            "label": "Program group command line",
            "sbg:category": ""
          },
          {
            "id": "#output_type",
            "type": [
              "null",
              {
                "symbols": [
                  "BAM",
                  "SAM",
                  "SAME AS INPUT"
                ],
                "name": "output_type",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "SAME AS INPUT",
            "description": "Since Picard tools can output both SAM and BAM files, user can choose the format of the output file.",
            "label": "Output format",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Optical duplicate pixel distance",
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "OPTICAL_DUPLICATE_PIXEL_DISTANCE="
            },
            "sbg:toolDefaultValue": "100",
            "description": "The maximum offset between two duplicate clusters in order to consider them optical duplicates. This should usually be set to some fairly small number (e.g. 5-10 pixels) unless using later versions of the Illumina pipeline that multiply pixel values by 10, in which case 50-100 is more normal. Default value: 100. This option can be set to 'null' to clear the default value.",
            "id": "#optical_duplicate_pixel_distance",
            "sbg:category": ""
          },
          {
            "id": "#memory_per_job",
            "sbg:toolDefaultValue": "2048",
            "type": [
              "null",
              "int"
            ],
            "label": "Memory per job",
            "description": "Amount of RAM memory to be used per job. Defaults to 2048MB for single threaded jobs."
          },
          {
            "sbg:altPrefix": "MAX_SEQS=",
            "id": "#max_sequences_for_disk_read_ends_map",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "MAX_SEQUENCES_FOR_DISK_READ_ENDS_MAP="
            },
            "sbg:toolDefaultValue": "50000",
            "description": "This option is obsolete. ReadEnds will always be spilled to disk. Default value: 50000. This option can be set to 'null' to clear the default value.",
            "label": "Max sequences for disk read ends map",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max records in RAM",
            "inputBinding": {
              "position": 4,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "MAX_RECORDS_IN_RAM="
            },
            "sbg:toolDefaultValue": "500000",
            "description": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000. This option can be set to 'null' to clear the default value.",
            "id": "#max_records_in_ram",
            "sbg:category": ""
          },
          {
            "sbg:altPrefix": "MAX_FILE_HANDLES=",
            "id": "#max_file_handles_for_read_ends_map",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "MAX_FILE_HANDLES_FOR_READ_ENDS_MAP="
            },
            "sbg:toolDefaultValue": "8000",
            "description": "Maximum number of file handles to keep open when spilling read ends to disk. Set this number a little lower than the per-process maximum number of file that may be open. This number can be found by executing the 'ulimit -n' command on a Unix system. Default value: 8000. This option can be set to 'null' to clear the default value.",
            "label": "Max file handles for read ends map",
            "sbg:category": ""
          },
          {
            "description": "This parameter indicates one or more input SAM or BAM files to analyze. Must be coordinate sorted.  Default value: null. This option may be specified 0 or more times.",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "INPUT=",
              "itemSeparator": null,
              "sbg:cmdInclude": true
            },
            "sbg:altPrefix": "I",
            "sbg:category": "File inputs",
            "required": true,
            "id": "#input_bam",
            "sbg:fileTypes": "SAM, BAM",
            "label": "Input bam"
          },
          {
            "id": "#duplicate_scoring_strategy",
            "label": "Duplicate scoring strategy",
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "DUPLICATE_SCORING_STRATEGY="
            },
            "sbg:toolDefaultValue": "SUM_OF_BASE_QUALITIES",
            "sbg:altPrefix": "DS",
            "type": [
              "null",
              {
                "symbols": [
                  "SUM_OF_BASE_QUALITIES",
                  "TOTAL_MAPPED_REFERENCE_LENGTH"
                ],
                "name": "duplicate_scoring_strategy",
                "type": "enum"
              }
            ],
            "description": "This parameter indicates the scoring strategy for choosing the non-duplicate among candidates."
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "name": "create_index",
                "type": "enum"
              }
            ],
            "label": "Create index",
            "inputBinding": {
              "position": 5,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "CREATE_INDEX="
            },
            "sbg:toolDefaultValue": "False",
            "description": "This parameter indicates whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: False. This option can be set to 'null' to clear the default value. Possible values: {True, False}.",
            "id": "#create_index",
            "sbg:category": ""
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Compression level",
            "inputBinding": {
              "position": 4,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "COMPRESSION_LEVEL="
            },
            "sbg:toolDefaultValue": "5",
            "description": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5. This option can be set to 'null' to clear the default value.",
            "id": "#compression_level",
            "sbg:category": ""
          },
          {
            "id": "#comment",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "position": 9,
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "COMMENT="
            },
            "sbg:altPrefix": "CO",
            "description": "Comment(s) to include in the output file's header. Default value: null. This option may be specified 0 or more times.",
            "label": "Comment",
            "sbg:category": ""
          },
          {
            "sbg:altPrefix": "AS",
            "id": "#assume_sorted",
            "type": [
              "null",
              {
                "symbols": [
                  "true",
                  "false"
                ],
                "name": "assume_sorted",
                "type": "enum"
              }
            ],
            "inputBinding": {
              "separate": false,
              "sbg:cmdInclude": true,
              "prefix": "ASSUME_SORTED="
            },
            "sbg:toolDefaultValue": "false",
            "description": "If this parameter is set to true, it is assumed that the input file is coordinate sorted even if the header says otherwise.  Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "label": "Assume sorted",
            "sbg:category": ""
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "dave",
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/picard-markduplicates-1-140/2",
            "sbg:modifiedOn": 1471439492
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "dave",
            "sbg:revisionNotes": "added bai to bam output",
            "sbg:modifiedOn": 1471449793
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "dave",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471449854
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "dave",
            "sbg:revisionNotes": "fixing bai output",
            "sbg:modifiedOn": 1471454504
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/mladenlsbg/picard:1.140",
            "class": "DockerRequirement",
            "dockerImageId": "eab0e70b6629"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  if($job.inputs.memory_per_job){\n  \treturn $job.inputs.memory_per_job\n  }\n  \treturn 2048\n}"
            },
            "class": "sbg:MemRequirement"
          }
        ],
        "description": "Picard MarkDuplicates examines aligned records in the supplied SAM or BAM file to locate duplicate molecules. All records are then written to the output file with the duplicate records flagged.",
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "engineCommand": "cwl-engine.js"
          }
        ],
        "id": "sarah/rd168-chern-newtests/picard-markduplicates-1-140/3",
        "sbg:license": "MIT License, Apache 2.0 Licence",
        "arguments": [
          {
            "separate": false,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  input_bam = [].concat($job.inputs.input_bam)\n  filename =input_bam[0].path.split('/').slice(-1)[0];\n  return filename.split('.').slice(0, -1).concat(\"metrics\").join(\".\");\n}"
            },
            "prefix": "METRICS_FILE=",
            "order": 4
          },
          {
            "separate": false,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  input_bam = [].concat($job.inputs.input_bam)\n  filename = input_bam[0].path.split('/').slice(-1)[0];\n  ext = $job.inputs.output_type;\n  filebase = filename.split('.').slice(0, -1).join('.') + '.deduped.';\n  \nif (ext === \"BAM\")\n{\n    return filebase + 'bam';\n    }\n\nelse if (ext === \"SAM\")\n{\n    return filebase + 'sam';\n}\n\nelse \n{\n\treturn filebase + filename.split('.').slice(-1)[0];\n}\n}"
            },
            "prefix": "OUTPUT=",
            "order": 2
          },
          {
            "position": 2001,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  input_bam = [].concat($job.inputs.input_bam)\n  filename = input_bam[0].path\n  \n  /* figuring out output file type */\n  ext = $job.inputs.output_type\n  if (ext === \"BAM\")\n  {\n    out_extension = \"BAM\"\n  }\n  else if (ext === \"SAM\")\n  {\n    out_extension = \"SAM\"\n  }\n  else \n  {\n\tout_extension = filename.split('.').slice(-1)[0].toUpperCase()\n  }  \n  \n  /* if exist moving .bai in bam.bai */\n  if ($job.inputs.create_index === 'True' && out_extension == \"BAM\")\n  {\n    \n    old_name = filename.split('.').slice(0, -1).concat('deduped.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    new_name = filename.split('.').slice(0, -1).concat('deduped.bam.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    return \"; mv \" + \" \" + old_name + \" \" + new_name\n  }\n\n}"
            },
            "separate": true
          }
        ],
        "stdout": "",
        "sbg:validationErrors": [],
        "sbg:createdOn": 1471439492,
        "baseCommand": [
          "java",
          {
            "class": "Expression",
            "engine": "#cwl-js-engine",
            "script": "{   \n  if($job.inputs.memory_per_job){\n    return '-Xmx'.concat($job.inputs.memory_per_job, 'M')\n  }   \n  \treturn '-Xmx2048M'\n}"
          },
          "-jar",
          "/opt/picard-tools-1.140/picard.jar",
          "MarkDuplicates"
        ],
        "sbg:toolkitVersion": "1.140",
        "stdin": "",
        "sbg:toolAuthor": "Broad Institute",
        "sbg:project": "sarah/rd168-chern-newtests",
        "sbg:modifiedBy": "dave",
        "class": "CommandLineTool",
        "sbg:revisionNotes": "fixing bai output",
        "sbg:sbgMaintained": false,
        "sbg:toolkit": "Picard",
        "sbg:job": {
          "inputs": {
            "input_bam": [
              {
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "input_bam.ext"
              }
            ],
            "memory_per_job": 0,
            "max_file_handles_for_read_ends_map": 0,
            "output_type": "BAM",
            "duplicate_scoring_strategy": "SUM_OF_BASE_QUALITIES"
          },
          "allocatedResources": {
            "mem": 2048,
            "cpu": 1
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 3,
        "sbg:contributors": [
          "dave"
        ],
        "sbg:links": [
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/picard/releases/tag/1.140",
            "label": "Source Code"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/broadinstitute/picard/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Publication"
          }
        ],
        "sbg:revision": 3,
        "sbg:createdBy": "dave",
        "y": 538.65625,
        "sbg:modifiedOn": 1471454504,
        "x": 1027,
        "label": "Picard MarkDuplicates",
        "sbg:categories": [
          "SAM/BAM-Processing"
        ]
      },
      "inputs": [
        {
          "id": "#Picard_MarkDuplicates.verbosity"
        },
        {
          "id": "#Picard_MarkDuplicates.validation_stringency"
        },
        {
          "id": "#Picard_MarkDuplicates.sorting_collections_size_ratio"
        },
        {
          "id": "#Picard_MarkDuplicates.remove_duplicates",
          "default": "true"
        },
        {
          "id": "#Picard_MarkDuplicates.read_name_regex"
        },
        {
          "id": "#Picard_MarkDuplicates.quiet"
        },
        {
          "id": "#Picard_MarkDuplicates.program_record"
        },
        {
          "id": "#Picard_MarkDuplicates.program_group_ver"
        },
        {
          "id": "#Picard_MarkDuplicates.program_group_name"
        },
        {
          "id": "#Picard_MarkDuplicates.program_group_command_line"
        },
        {
          "id": "#Picard_MarkDuplicates.output_type",
          "default": "BAM"
        },
        {
          "id": "#Picard_MarkDuplicates.optical_duplicate_pixel_distance"
        },
        {
          "source": [
            "#memory_per_job"
          ],
          "id": "#Picard_MarkDuplicates.memory_per_job"
        },
        {
          "id": "#Picard_MarkDuplicates.max_sequences_for_disk_read_ends_map"
        },
        {
          "id": "#Picard_MarkDuplicates.max_records_in_ram"
        },
        {
          "id": "#Picard_MarkDuplicates.max_file_handles_for_read_ends_map"
        },
        {
          "source": [
            "#STAR.aligned_reads"
          ],
          "id": "#Picard_MarkDuplicates.input_bam"
        },
        {
          "id": "#Picard_MarkDuplicates.duplicate_scoring_strategy",
          "default": "TOTAL_MAPPED_REFERENCE_LENGTH"
        },
        {
          "id": "#Picard_MarkDuplicates.create_index",
          "default": "True"
        },
        {
          "id": "#Picard_MarkDuplicates.compression_level"
        },
        {
          "id": "#Picard_MarkDuplicates.comment"
        },
        {
          "id": "#Picard_MarkDuplicates.assume_sorted",
          "default": "true"
        }
      ],
      "id": "#Picard_MarkDuplicates",
      "sbg:y": 538.65625
    },
    {
      "outputs": [
        {
          "id": "#SBG_Pair_FASTQs_by_Metadata.tuple_list"
        }
      ],
      "sbg:x": 59,
      "run": {
        "sbg:cmdPreview": "python pair_fastqs_by_metadata.py --fastq_list /asda/dsa/sda/sda/fasta1.fastq,/asda/dsa/sda/sda/fasta2.fastq,/asda/dsa/sda/sda/fasta3.fastq,/asda/dsa/sda/sda/fasta4.fastq --in_metafile job.json --out_metafile cwl.output.json",
        "outputs": [
          {
            "id": "#tuple_list",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ]
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:revisionNotes": "Added support for single file.",
        "inputs": [
          {
            "description": "List of the FASTQ files with properly set metadata fileds.",
            "type": [
              {
                "items": "File",
                "name": "fastq_list",
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 0,
              "separate": true,
              "prefix": "--fastq_list",
              "itemSeparator": ",",
              "sbg:cmdInclude": true
            },
            "sbg:stageInput": "link",
            "id": "#fastq_list",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
            "label": "List of FASTQ files"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799739
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799740
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799742
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1463578034
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1467884288
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1468402323
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Link fastq_list",
            "sbg:modifiedOn": 1470144392
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Added support for single file.",
            "sbg:modifiedOn": 1472135950
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/djordje_klisic/sbg-pair-fastqs-by-metadata:1.0",
            "class": "DockerRequirement",
            "dockerImageId": "d41a0837ab81"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1024,
            "class": "sbg:MemRequirement"
          }
        ],
        "description": "Tool accepts list of FASTQ files for one sample as the input and groups them into pairs  (two files for each paired end). This grouping is done using metadata values that are creating unique combination for each pair or of FASTQ files. Metadata that fields that are uniquely defining one FASTQ pair are Sample ID, Library ID, Platform unit ID and File segment number. Listed order of metadata fields is also representing their hierarchy in the metadata structure. Not all of these four metadata fields are required, but the present set has to be sufficient to create unique combinations for each pair of FASTQ files.",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "pair_fastqs_by_metadata.py",
                "fileContent": "import functools\nimport json\nimport itertools\nimport docopt\nimport types\nUSAGE = \"\"\"\n    Usage:\n    \tsbg_pair_fastqs_by_metadata.py --fastq_list FILE... --in_metafile FILE --out_metafile FILE [options]\n\n    Description:\n        Tool accepts list of FATSQ files for one sample as the input and groups them into pairs\n        (two files for each paired end). This grouping is done using metadata values that are creating\n        unique combination for each pair or of FASTQ files. Metadata that fields that are uniquely defining\n        one FASTQ pair are Sample ID, Library ID, Platform Unit ID and File Segment Number. Listed order of metadata fields is also\n        representing their hierarchy in the metadata structure. Not all of these four metadata fields are required,\n        but the present set has to be sufficient to create unique combinations for each pair of FASTQ files.\n\n    Options:\n\n        --help                                Show help dialog.\n\n        --version                             Tool version.\n\n        --fatsq_list FILE...                  List of the FASTQ files with properly set metadata fileds.\n\n        --in_metafile FILE                    File from which necessary metadata information will be extracted.\n                                              Expected value for the SBG platfrom is job.json. [Default: job.json]\n\n        --out_metafile FILE                   File into which necessary file structure is going to be written.\n                                              Expected value for the SBG platform is cwl.output.json.\n                                              [Default: cwl.output.json]\n\n\n\"\"\"\n\ndef make_rg_id(metadata_key, input1):\n\n    input_meta = input1.values()[0]\n\n    S = '__!__'\n    rg = list()\n    for key in ['sample_group', 'sample_id', 'library_id', 'platform_unit_id']:\n        if key in input_meta:\n            rg.append(input_meta[key])\n        else:\n            rg.append('')\n    if 'file_segment_number' in input_meta and input_meta['file_segment_number'] is not None:\n        rg.append(str(input_meta['file_segment_number']))\n    else:\n        rg.append('')\n\n    rg_map = {\n        'sample_id': rg[:2],\n        'library_id': rg[:3],\n        'platform_unit_id': rg[:4],\n        'file_segment_number': rg[:5],\n    }\n\n    return S.join(rg_map[metadata_key]) if metadata_key in rg_map else getattr(input_meta, metadata_key)\n\n\ndef group_inputs(inp):\n\n    metadata_key = 'file_segment_number'\n    if str(metadata_key) == 'None':\n        return {'': [f for f in inp]}\n    if metadata_key == 'file':\n        return {f: [f] for f in inp}\n    key_getter = functools.partial(make_rg_id, metadata_key)\n    print inp\n    files = sorted([x for x in inp], key=key_getter)\n    tuple_list_temp = [[f for f in val] for key, val in itertools.groupby(files, key_getter)]\n    tuple_list=list()\n    for elem in tuple_list_temp:\n        for key in elem[0].keys():\n            if len(files) != 1:\n                if elem[0][key]['paired_end'] == \"2\":\n                    tuple_list.append([str(elem[1].keys()[0]), str(elem[0].keys()[0])])\n                else:\n                    tuple_list.append([str(elem[0].keys()[0]), str(elem[1].keys()[0])])\n            else:\n                    tuple_list.append([str(elem[0].keys()[0])])\n\n    print tuple_list\n    return tuple_list\n\ndef main():\n\n    args = docopt.docopt(USAGE, version = 1.0)\n\n    job_json = args[\"--in_metafile\"]\n    job_json_file = open(job_json)\n    job_json_str = job_json_file.read()\n    job_json_dict = json.loads(job_json_str)\n    fastq_list = job_json_dict['inputs'][\"fastq_list\"]\n    if isinstance(fastq_list, list):\n        fastq_list = job_json_dict['inputs'][\"fastq_list\"]\n    else:\n        fastq_list = list()\n        fastq_list.append(job_json_dict['inputs'][\"fastq_list\"])\n    file_list = [{elem['path'] : elem['metadata']} for elem in fastq_list]\n    tuple_list = group_inputs(file_list)\n\n    for elem in tuple_list:\n        for i in range(0,len(elem)):\n            elem[i] = {\"class\": \"File\", \"path\": elem[i]}\n\n\n    tuple_list_dict = {\"tuple_list\": tuple_list}\n    with open(args[\"--out_metafile\"], 'w') as p:\n        json.dump(tuple_list_dict, p)\n\nif __name__ == '__main__':\n    main()"
              }
            ]
          }
        ],
        "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/sbg-pair-fastqs-by-metadata/7/raw/",
        "sbg:license": "Apache License 2.0",
        "arguments": [
          {
            "position": 1,
            "valueFrom": "job.json",
            "prefix": "--in_metafile",
            "separate": true
          },
          {
            "position": 2,
            "valueFrom": "cwl.output.json",
            "prefix": "--out_metafile",
            "separate": true
          }
        ],
        "label": "SBG Pair FASTQs by Metadata",
        "sbg:validationErrors": [],
        "baseCommand": [
          "python",
          "pair_fastqs_by_metadata.py"
        ],
        "stdin": "",
        "sbg:toolAuthor": "Djordje Klisic, Seven Bridges Genomics, <djordje.klisic@sbgenomics.com>",
        "sbg:project": "admin/sbg-public-data",
        "sbg:modifiedBy": "admin",
        "class": "CommandLineTool",
        "sbg:revision": 7,
        "sbg:sbgMaintained": false,
        "sbg:toolkit": "SBGTools",
        "sbg:job": {
          "inputs": {
            "fastq_list": [
              {
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/asda/dsa/sda/sda/fasta1.fastq"
              },
              {
                "path": "/asda/dsa/sda/sda/fasta2.fastq"
              },
              {
                "path": "/asda/dsa/sda/sda/fasta3.fastq"
              },
              {
                "path": "/asda/dsa/sda/sda/fasta4.fastq"
              }
            ]
          },
          "allocatedResources": {
            "mem": 1024,
            "cpu": 1
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 7,
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "sbg:links": [
          {
            "id": "https://cgc.sbgenomics.com/u/stefanristeski/group-fastqs/apps/#sbg-pair-fastqs-by-metadata/9",
            "label": "Homepage"
          }
        ],
        "stdout": "",
        "sbg:createdBy": "sevenbridges",
        "sbg:createdOn": 1453799739,
        "sbg:modifiedOn": 1472135950,
        "sbg:id": "admin/sbg-public-data/sbg-pair-fastqs-by-metadata/7",
        "sbg:categories": [
          "Converters",
          "Other"
        ]
      },
      "inputs": [
        {
          "source": [
            "#reads"
          ],
          "id": "#SBG_Pair_FASTQs_by_Metadata.fastq_list"
        }
      ],
      "id": "#SBG_Pair_FASTQs_by_Metadata",
      "sbg:y": 117.65625
    },
    {
      "id": "#Eautils_Fastq_mcf",
      "outputs": [
        {
          "id": "#Eautils_Fastq_mcf.filtered_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.skipped_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.summary"
        }
      ],
      "sbg:x": 276,
      "scatter": "#Eautils_Fastq_mcf.reads",
      "inputs": [
        {
          "id": "#Eautils_Fastq_mcf.minimum_length_match"
        },
        {
          "id": "#Eautils_Fastq_mcf.adapter_occurrence_threshold"
        },
        {
          "id": "#Eautils_Fastq_mcf.min_clip_length"
        },
        {
          "id": "#Eautils_Fastq_mcf.maximum_adapter_difference"
        },
        {
          "id": "#Eautils_Fastq_mcf.minimum_remaining_sequence_length",
          "default": 48
        },
        {
          "id": "#Eautils_Fastq_mcf.maximum_remaining_sequence_length"
        },
        {
          "id": "#Eautils_Fastq_mcf.remove_duplicate_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.skew_percentage",
          "default": 2
        },
        {
          "id": "#Eautils_Fastq_mcf.bad_read_percentage_threshold",
          "default": 1
        },
        {
          "id": "#Eautils_Fastq_mcf.quality_threshold",
          "default": 10
        },
        {
          "id": "#Eautils_Fastq_mcf.trimming_window_size"
        },
        {
          "id": "#Eautils_Fastq_mcf.remove_homopolymer_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.set_all_default_parameters_to_zero/do_nothing"
        },
        {
          "id": "#Eautils_Fastq_mcf.illumina_pf"
        },
        {
          "id": "#Eautils_Fastq_mcf.phred-scale"
        },
        {
          "id": "#Eautils_Fastq_mcf.dont_remove_ns"
        },
        {
          "id": "#Eautils_Fastq_mcf.dont_clip"
        },
        {
          "id": "#Eautils_Fastq_mcf.number_of_reads_to_use_for_subsampling",
          "default": 300000
        },
        {
          "id": "#Eautils_Fastq_mcf.save_discarded_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.output_lots_of_random_debugging_stuff"
        },
        {
          "id": "#Eautils_Fastq_mcf.cycle_adjust"
        },
        {
          "id": "#Eautils_Fastq_mcf.phred_adjust"
        },
        {
          "id": "#Eautils_Fastq_mcf.qual_mean"
        },
        {
          "id": "#Eautils_Fastq_mcf.qual_gt"
        },
        {
          "id": "#Eautils_Fastq_mcf.max_ns"
        },
        {
          "id": "#Eautils_Fastq_mcf.min_len"
        },
        {
          "id": "#Eautils_Fastq_mcf.mate_qual_mean"
        },
        {
          "id": "#Eautils_Fastq_mcf.mate_qual_gt"
        },
        {
          "id": "#Eautils_Fastq_mcf.mate_max_ns"
        },
        {
          "id": "#Eautils_Fastq_mcf.mate_min_len"
        },
        {
          "id": "#Eautils_Fastq_mcf.hompolymer_pct"
        },
        {
          "source": [
            "#adapters"
          ],
          "id": "#Eautils_Fastq_mcf.adapters"
        },
        {
          "source": [
            "#SBG_Pair_FASTQs_by_Metadata.tuple_list"
          ],
          "id": "#Eautils_Fastq_mcf.reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.keep_only_clipped_reads"
        },
        {
          "id": "#Eautils_Fastq_mcf.phred_adjust_max"
        },
        {
          "id": "#Eautils_Fastq_mcf.output_n_records"
        },
        {
          "id": "#Eautils_Fastq_mcf.lowcomplex_pct"
        },
        {
          "id": "#Eautils_Fastq_mcf.keep_clipped"
        },
        {
          "id": "#Eautils_Fastq_mcf.max_output_reads"
        }
      ],
      "run": {
        "sbg:cmdPreview": "/opt/ea-utils/ea-utils.1.1.2-806/fastq-mcf -o Sample1.pe_1.filtered.fastq.gz -o Sample1.pe_2.filtered.fastq.gz   /dir/Sample1.pe_1.fastq /dir/Sample1.pe_2.fastq > Sample1.fastqmcf_summary.txt",
        "outputs": [
          {
            "id": "#filtered_reads",
            "outputBinding": {
              "sbg:metadata": {
                "paired_end": {
                  "class": "Expression",
                  "engine": "#cwl-js-engine",
                  "script": "{\n  filename = $self.path.split('/').slice(-1)[0]\n  filebase = filename.split('.').slice(0, -3).join('.')\n  \n  reads = [].concat($job.inputs.reads)\n      \n  for (i=0; i<reads.length; i++)\n  {\n    input_filename = reads[i].path.split('/').slice(-1)[0]\n    input_filebase = input_filename.split('.').slice(0, -1).join('.')\n      \n    if (filebase==input_filebase && $job.inputs.reads[i].metadata && $job.inputs.reads[i].metadata.paired_end)\n    {\n      return $job.inputs.reads[i].metadata.paired_end\n    }\n  }\n}"
                }
              },
              "glob": "*.filtered.fastq.gz",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              {
                "items": "File",
                "name": "filtered_reads",
                "type": "array"
              }
            ],
            "description": "FASTQ files processed according to the set parameters.",
            "sbg:fileTypes": "FASTQ,FQ,FASTQ.GZ",
            "label": "Filtered reads"
          },
          {
            "id": "#skipped_reads",
            "outputBinding": {
              "glob": "*.filtered.fastq.skip.gz",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              {
                "items": "File",
                "name": "skipped_reads",
                "type": "array"
              }
            ],
            "description": "FASTQ files containing reads that were filtered out from the input.",
            "sbg:fileTypes": "FASTQ,FQ,FASTQ.GZ",
            "label": "Skipped reads"
          },
          {
            "id": "#summary",
            "outputBinding": {
              "glob": "*.txt",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              {
                "items": "File",
                "name": "summary",
                "type": "array"
              }
            ],
            "description": "A text file containing summary of the filtration.",
            "sbg:fileTypes": "TXT",
            "label": "Summary"
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:id": "admin/sbg-public-data/eautils-fastq-mcf-1-1-2/7",
        "inputs": [
          {
            "sbg:altPrefix": null,
            "id": "#minimum_length_match",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-s"
            },
            "sbg:toolDefaultValue": "2.2",
            "description": "Log scale for adapter minimum-length-match.",
            "label": "Minimum length match",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#adapter_occurrence_threshold",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-t"
            },
            "sbg:toolDefaultValue": "0.25",
            "description": "% occurance threshold before adapter clipping.",
            "label": "Adapter occurrence threshold",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#min_clip_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-m"
            },
            "sbg:toolDefaultValue": "1",
            "description": "Minimum clip length, overrides scaled auto.",
            "label": "Min clip length",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#maximum_adapter_difference",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-p"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Maximum adapter difference percentage.",
            "label": "Max adapter difference",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#minimum_remaining_sequence_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-l"
            },
            "sbg:toolDefaultValue": "19",
            "description": "Minimum remaining sequence length.",
            "label": "Minimum remaining sequence length",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#maximum_remaining_sequence_length",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-L"
            },
            "sbg:toolDefaultValue": null,
            "description": "Maximum remaining sequence length.",
            "label": "Maximum remaining sequence length",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#remove_duplicate_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-D"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Remove duplicate reads : Read_1 has an identical N bases.",
            "label": "Remove duplicate reads",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#skew_percentage",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-k"
            },
            "sbg:toolDefaultValue": "2",
            "description": "SKew percentage-less-than causing cycle removal.",
            "label": "SKew percentage",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#bad_read_percentage_threshold",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-x"
            },
            "sbg:toolDefaultValue": "20",
            "description": "'N' (Bad read) percentage causing cycle removal.",
            "label": "Bad read percentage threshold",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#quality_threshold",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-q"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Quality threshold causing base removal.",
            "label": "Quality threshold",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#trimming_window_size",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-w"
            },
            "sbg:toolDefaultValue": "1",
            "description": "Window-size for quality trimming.",
            "label": "Trimming window size",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#remove_homopolymer_reads",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-H"
            },
            "sbg:toolDefaultValue": false,
            "description": "Remove >95% homopolymer read.",
            "label": "Remove homopolymer reads",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#set_all_default_parameters_to_zero/do_nothing",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-0"
            },
            "sbg:toolDefaultValue": false,
            "description": "Set all default parameters to zero/do nothing.",
            "label": "Set all default parameters to zero/do nothing",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#illumina_pf",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-U"
            },
            "sbg:toolDefaultValue": false,
            "description": "Force disable/enable Illumina PF filtering.",
            "label": "Illumina PF",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#phred-scale",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-P"
            },
            "sbg:toolDefaultValue": "auto",
            "description": "Phred-scale.",
            "label": "Phred-scale",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#dont_remove_ns",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-R"
            },
            "sbg:toolDefaultValue": false,
            "description": "Don't remove N's from the fronts/ends of reads.",
            "label": "Dont remove Ns",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#dont_clip",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-n"
            },
            "sbg:toolDefaultValue": false,
            "description": "Dont clip, just output what would be done.",
            "label": "Don't clip",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#number_of_reads_to_use_for_subsampling",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-C"
            },
            "sbg:toolDefaultValue": "300k",
            "description": "Number of reads to use for subsampling.",
            "label": "Number of reads to use for subsampling",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#save_discarded_reads",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-S"
            },
            "sbg:toolDefaultValue": false,
            "description": "Save all discarded reads to '.skip' files.",
            "label": "Save discarded reads",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#output_lots_of_random_debugging_stuff",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-d"
            },
            "sbg:toolDefaultValue": false,
            "description": "Output lots of random debugging stuff.",
            "label": "Output lots of random debugging stuff",
            "sbg:category": "Options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#cycle_adjust",
            "type": [
              "null",
              {
                "items": {
                  "type": "int"
                },
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 0,
              "separate": true,
              "prefix": "--cycle-adjust",
              "itemSeparator": ",",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": null,
            "description": "Adjust cycle CYC (negative = offset from end) by amount AMT.",
            "label": "Adjust cycle",
            "sbg:category": "Quality adjustment options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#phred_adjust",
            "type": [
              "null",
              {
                "items": {
                  "type": "int"
                },
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 1,
              "separate": true,
              "prefix": "--phred-adjust",
              "itemSeparator": ",",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": null,
            "description": "Adjust score SCORE by amount AMT.",
            "label": "Adjust score",
            "sbg:category": "Quality adjustment options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#qual_mean",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--qual-mean"
            },
            "sbg:toolDefaultValue": null,
            "description": "Minimum mean quality score.",
            "label": "Minimum mean quality score",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#qual_gt",
            "type": [
              "null",
              {
                "items": {
                  "type": "float"
                },
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 2,
              "separate": true,
              "prefix": "--qual-gt",
              "itemSeparator": ",",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": null,
            "description": "At least NUM quals > THR.",
            "label": "Quality greater than threshold",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#max_ns",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--max-ns"
            },
            "sbg:toolDefaultValue": null,
            "description": "Maxmium N-calls in a read (can be a %).",
            "label": "Maxmium N-calls",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#min_len",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--min-len"
            },
            "sbg:toolDefaultValue": null,
            "description": "Minimum remaining length (same as -l).",
            "label": "Minimum remaining length",
            "sbg:category": "Filtering options"
          },
          {
            "id": "#mate_qual_mean",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mate-qual-mean"
            },
            "description": "Minimum mean quality score, applies to second non-barcode read only.",
            "label": "Mate quality minimum score",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#mate_qual_gt",
            "type": [
              "null",
              {
                "items": {
                  "type": "float"
                },
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 3,
              "separate": true,
              "prefix": "--mate-qual-gt",
              "itemSeparator": ",",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": null,
            "description": "At least NUM quals > THR.",
            "label": "Quality greater than threshold, applies to second non-barcode read only",
            "sbg:category": "Filtering options"
          },
          {
            "id": "#mate_max_ns",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mate-max-ns"
            },
            "description": "Maximum N-calls in a read (can be a %), applies to second non-barcode read only.",
            "label": "Mate maxmium N-calls in a read",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#mate_min_len",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--mate-min-len"
            },
            "sbg:toolDefaultValue": null,
            "description": "Minimum remaining length (same as -l).",
            "label": "Mate minimum remaining length",
            "sbg:category": "Filtering options"
          },
          {
            "sbg:altPrefix": null,
            "id": "#hompolymer_pct",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--hompolymer-pct"
            },
            "sbg:toolDefaultValue": null,
            "description": "Homopolymer filter percentage, evaluated after clipping/trimming.",
            "label": "Homopolymer filter percentage",
            "sbg:category": "Filtering options"
          },
          {
            "description": "A list of adapters to clip in FASTA format.",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "position": 100,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  if  ($job.inputs.adapters)\n  {\n    return $job.inputs.adapters.path\n    \n  }\n  else\n  {\n    return \"-f /dev/null\"\n  }\n\t\n}"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "label": "Adapters",
            "id": "#adapters",
            "sbg:fileTypes": "FASTA, FA",
            "sbg:category": "File inputs"
          },
          {
            "description": "A single FASTQ file for single end or two files for paired end experiments.",
            "type": [
              {
                "items": "File",
                "name": "reads",
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 101,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  reads = [].concat($job.inputs.reads)\n  var first_read= null, second_read=null, all_reads = reads[0].path+ ' ';\n  \n  for (i=0; i<reads.length; i++)\n  {\n    if (i>0)\n    {\n      all_reads = all_reads + reads[i].path + ' '\n    }\n    \n    if (reads[i].metadata && reads[i].metadata.paired_end)\n    {\n      if (reads[i].metadata.paired_end == 1)\n      {\n        first_read = reads[i].path\n      }\n      if (reads[i].metadata.paired_end == 2)\n      {\n        second_read = reads[i].path\n      }\n    }\n  }\n  \n  if ((first_read) && (second_read))\n  {\n    return first_read + ' ' + second_read\n  }\n  else\n  {\n    return all_reads\n  }\n}"
              },
              "sbg:cmdInclude": true,
              "itemSeparator": null,
              "separate": true
            },
            "label": "Reads",
            "id": "#reads",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
            "sbg:category": "File inputs"
          },
          {
            "id": "#keep_only_clipped_reads",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-K"
            },
            "description": "Only keep clipped reads.",
            "label": "Keep only clipped reads",
            "sbg:category": "Options"
          },
          {
            "id": "#phred_adjust_max",
            "type": [
              "null",
              "float"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--phred-adjust-max"
            },
            "description": "Adjust scores > SCORE to SCOTE.",
            "label": "Phred adjust max",
            "sbg:category": "Quality adjustment options"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Output N records",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-O"
            },
            "sbg:toolDefaultValue": "All",
            "description": "Only output the first N records.",
            "id": "#output_n_records",
            "sbg:category": "Options"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Complexity filter",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--lowcomplex-pct"
            },
            "sbg:toolDefaultValue": "95",
            "description": "Complexity filter percent.",
            "id": "#lowcomplex_pct",
            "sbg:category": "Filtering options"
          },
          {
            "id": "#keep_clipped",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--keep-clipped"
            },
            "description": "Only keep clipped (same as -K).",
            "label": "Keep clipped",
            "sbg:category": "Filtering options"
          },
          {
            "id": "#max_output_reads",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--max-output-reads"
            },
            "description": "Only output first N records (same as -O).",
            "label": "Max output reads",
            "sbg:category": "Filtering options"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453800010
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453800010
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453800012
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453800014
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1458574298
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1461762649
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": "Added inherit_metadata to summary.txt output.",
            "sbg:modifiedOn": 1467818645
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Updated links and descriptions.",
            "sbg:modifiedOn": 1471539430
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/mladenlsbg/eautils:1.1.2",
            "class": "DockerRequirement",
            "dockerImageId": "cfe18806c289"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          }
        ],
        "description": "Detects levels of adapter presence, computes likelihoods and locations (start, end) of the adapters. Removes the adapter sequences from the FASTQ file(s).",
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/eautils-fastq-mcf-1-1-2/7/raw/",
        "sbg:license": "MIT License",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  out = ''\n  reads = [].concat($job.inputs.reads)\n      \n    for (i=0; i<reads.length; i++)\n    {\n      filename = reads[i].path.split('/').slice(-1)[0]\n      filebase = filename.split('.').slice(0, -1).join('.').concat('.filtered.fastq.gz')\n      out_elem = \"-o \".concat(filebase).concat(\" \")\n      out = out.concat(out_elem)\n  \t}\n  \n  return out  \n}"
            },
            "separate": false
          }
        ],
        "stdout": {
          "class": "Expression",
          "engine": "#cwl-js-engine",
          "script": "{\n  reads = [].concat($job.inputs.reads)\n  file_path = reads[0].path\n  filename = file_path.split('/').slice(-1)[0]\n  filebase = filename.split('.').slice(0, 1).join('.')\n  out_name = filebase.concat(\".fastqmcf_summary.txt\")\n  return out_name\n  \n  \n}"
        },
        "sbg:validationErrors": [],
        "baseCommand": [
          "/opt/ea-utils/ea-utils.1.1.2-806/fastq-mcf"
        ],
        "sbg:toolkitVersion": "1.1.2",
        "stdin": "",
        "sbg:toolAuthor": "Erik Aronesty",
        "sbg:project": "admin/sbg-public-data",
        "sbg:modifiedBy": "admin",
        "class": "CommandLineTool",
        "sbg:revisionNotes": "Updated links and descriptions.",
        "sbg:sbgMaintained": false,
        "sbg:toolkit": "Eautils",
        "sbg:job": {
          "inputs": {
            "output_n_records": 0,
            "max_output_reads": 0,
            "keep_only_clipped_reads": true,
            "adapters": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": null
            },
            "keep_clipped": true,
            "reads": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/dir/Sample1.pe_1.fastq"
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "secondaryFiles": [],
                "path": "/dir/Sample1.pe_2.fastq"
              }
            ],
            "lowcomplex_pct": 0,
            "phred_adjust_max": 0
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 7,
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "sbg:links": [
          {
            "id": "http://expressionanalysis.github.io/ea-utils/",
            "label": "Homepage"
          },
          {
            "id": "https://code.google.com/p/ea-utils/source/checkout",
            "label": "Source code"
          },
          {
            "id": "https://code.google.com/p/ea-utils/wiki/FastqMcf",
            "label": "Wiki"
          },
          {
            "id": "https://drive.google.com/folderview?id=0B7KhouP0YeRAOTFWWGVFYkFSQjg&usp=sharing",
            "label": "Download"
          },
          {
            "id": "http://benthamopen.com/ABSTRACT/TOBIOIJ-7-1",
            "label": "Publication"
          }
        ],
        "sbg:revision": 7,
        "sbg:createdBy": "sevenbridges",
        "sbg:createdOn": 1453800010,
        "sbg:modifiedOn": 1471539430,
        "label": "Eautils Fastq-mcf",
        "sbg:categories": [
          "FASTQ-Processing"
        ]
      },
      "sbg:y": 194.65625
    },
    {
      "outputs": [
        {
          "id": "#SBG_Flatten_1.flat"
        }
      ],
      "sbg:x": 625,
      "run": {
        "sbg:cmdPreview": "python /opt/sbg-flatten.py",
        "outputs": [
          {
            "id": "#flat",
            "outputBinding": {
              "sbg:metadata": {}
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "All grouped files",
            "description": "All grouped files as one list."
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:id": "admin/sbg-public-data/sbg-flatten/2",
        "inputs": [
          {
            "id": "#nested",
            "sbg:category": "Input files",
            "type": [
              {
                "items": "File",
                "type": "array"
              }
            ],
            "label": "Nested",
            "description": "Files from all SBG Group Input outputs should be provided."
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799658
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799659
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": "Changed to be able to flatten irregular list of lists.",
            "sbg:modifiedOn": 1471539420
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/ana_d/sbg-flatten:2.0",
            "class": "DockerRequirement",
            "dockerImageId": "c0e1d93b3d76"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          }
        ],
        "description": "SBG Flatten is used only with SBG Group Input app for purposes of providing grouped inputs. All SBG Group Input outputs should be passed to the \"Nested\" SBG Flatten input in order to produce the output with all grouped files as one list.",
        "requirements": [],
        "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/sbg-flatten/2/raw/",
        "sbg:license": "Apache License 2.0",
        "arguments": [],
        "stdout": "",
        "sbg:validationErrors": [],
        "baseCommand": [
          "python",
          "/opt/sbg-flatten.py"
        ],
        "sbg:toolkitVersion": "1.0",
        "stdin": "",
        "sbg:toolAuthor": "Ana Damljanovic/ Seven Bridges Genomics",
        "sbg:project": "admin/sbg-public-data",
        "sbg:modifiedBy": "admin",
        "class": "CommandLineTool",
        "sbg:revisionNotes": "Changed to be able to flatten irregular list of lists.",
        "sbg:sbgMaintained": false,
        "sbg:toolkit": "SBGTools",
        "sbg:job": {
          "inputs": {
            "nested": "nested"
          },
          "allocatedResources": {
            "mem": 1000,
            "cpu": 1
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 2,
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "sbg:revision": 2,
        "sbg:createdBy": "sevenbridges",
        "sbg:createdOn": 1453799658,
        "sbg:modifiedOn": 1471539420,
        "label": "SBG Flatten",
        "sbg:categories": [
          "Other"
        ]
      },
      "inputs": [
        {
          "source": [
            "#Eautils_Fastq_mcf.summary"
          ],
          "id": "#SBG_Flatten_1.nested"
        }
      ],
      "id": "#SBG_Flatten_1",
      "sbg:y": 71.65625
    },
    {
      "outputs": [
        {
          "id": "#STAR.aligned_reads"
        },
        {
          "id": "#STAR.transcriptome_aligned_reads"
        },
        {
          "id": "#STAR.reads_per_gene"
        },
        {
          "id": "#STAR.log_files"
        },
        {
          "id": "#STAR.splice_junctions"
        },
        {
          "id": "#STAR.chimeric_junctions"
        },
        {
          "id": "#STAR.unmapped_reads"
        },
        {
          "id": "#STAR.intermediate_genome"
        },
        {
          "id": "#STAR.chimeric_alignments"
        }
      ],
      "sbg:x": 790,
      "run": {
        "sbg:cmdPreview": "tar -xvf genome.ext && /opt/STAR --runThreadN 15  --readFilesCommand bzcat  --sjdbGTFfile /demo/test-data/chr20.gtf  --sjdbGTFchrPrefix chrPrefix --sjdbInsertSave Basic  --twopass1readsN -1  --chimOutType WithinBAM  --outSAMattrRGline ID:1 CN:illumina PI:rg_mfl PL:Ion_Torrent_PGM PU:rg_platform_unit SM:rg_sample  --quantMode TranscriptomeSAM --outFileNamePrefix ./mate_1.fastq.bz2.  --readFilesIn /test-data/mate_1.fastq.bz2  && tar -vcf mate_1.fastq.bz2._STARgenome.tar ./mate_1.fastq.bz2._STARgenome  && mv mate_1.fastq.bz2.Unmapped.out.mate1 mate_1.fastq.bz2.Unmapped.out.mate1.fastq",
        "outputs": [
          {
            "id": "#aligned_reads",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  if ($job.inputs.outSortingType == 'SortedByCoordinate') {\n    sort_name = '.sortedByCoord'\n  }\n  else {\n    sort_name = ''\n  }\n  if ($job.inputs.outSAMtype == 'BAM') {\n    sam_name = \"*.Aligned\".concat( sort_name, '.out.bam')\n  }\n  else {\n    sam_name = \"*.Aligned.out.sam\"\n  }\n  return sam_name\n}"
              },
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "Aligned sequence in SAM/BAM format.",
            "sbg:fileTypes": "SAM, BAM",
            "label": "Aligned SAM/BAM"
          },
          {
            "id": "#transcriptome_aligned_reads",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*Transcriptome*",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "Alignments translated into transcript coordinates.",
            "sbg:fileTypes": "BAM",
            "label": "Transcriptome alignments"
          },
          {
            "id": "#reads_per_gene",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*ReadsPerGene*",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "File with number of reads per gene. A read is counted if it overlaps (1nt or more) one and only one gene.",
            "sbg:fileTypes": "TAB",
            "label": "Reads per gene"
          },
          {
            "id": "#log_files",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*Log*.out",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "description": "Log files produced during alignment.",
            "sbg:fileTypes": "OUT",
            "label": "Log files"
          },
          {
            "id": "#splice_junctions",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*SJ.out.tab",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "High confidence collapsed splice junctions in tab-delimited format. Only junctions supported by uniquely mapping reads are reported.",
            "sbg:fileTypes": "TAB",
            "label": "Splice junctions"
          },
          {
            "id": "#chimeric_junctions",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*Chimeric.out.junction",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "If chimSegmentMin in 'Chimeric Alignments' section is set to 0, 'Chimeric Junctions' won't be output.",
            "sbg:fileTypes": "JUNCTION",
            "label": "Chimeric junctions"
          },
          {
            "id": "#unmapped_reads",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*Unmapped.out*",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "description": "Output of unmapped reads.",
            "sbg:fileTypes": "FASTQ",
            "label": "Unmapped reads"
          },
          {
            "id": "#intermediate_genome",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*_STARgenome.tar",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "Archive with genome files produced when annotations are included on the fly (in the mapping step).",
            "sbg:fileTypes": "TAR",
            "label": "Intermediate genome files"
          },
          {
            "id": "#chimeric_alignments",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*.Chimeric.out.sam",
              "sbg:inheritMetadataFrom": "#reads"
            },
            "type": [
              "null",
              "File"
            ],
            "description": "Aligned Chimeric sequences SAM - if chimSegmentMin = 0, no Chimeric Alignment SAM and Chimeric Junctions outputs.",
            "sbg:fileTypes": "SAM",
            "label": "Chimeric alignments"
          }
        ],
        "successCodes": [],
        "sbg:image_url": null,
        "sbg:id": "admin/sbg-public-data/star/11",
        "inputs": [
          {
            "description": "Read sequence. In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "items": "File",
                "name": "reads",
                "type": "array"
              }
            ],
            "inputBinding": {
              "position": 10,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\t\n  var list = [].concat($job.inputs.reads)\n  \n  var resp = []\n  \n  if (list.length == 1){\n    resp.push(list[0].path)\n    \n  }else if (list.length == 2){    \n    \n    left = \"\"\n    right = \"\"\n      \n    for (index = 0; index < list.length; ++index) {\n      \n      if (list[index].metadata != null){\n        if (list[index].metadata.paired_end == 1){\n          left = list[index].path\n        }else if (list[index].metadata.paired_end == 2){\n          right = list[index].path\n        }\n      }\n    }\n    \n    if (left != \"\" && right != \"\"){      \n      resp.push(left)\n      resp.push(right)\n    }\n  }\n  else if (list.length > 2){\n    left = []\n    right = []\n      \n    for (index = 0; index < list.length; ++index) {\n      \n      if (list[index].metadata != null){\n        if (list[index].metadata.paired_end == 1){\n          left.push(list[index].path)\n        }else if (list[index].metadata.paired_end == 2){\n          right.push(list[index].path)\n        }\n      }\n    }\n    left_join = left.join()\n    right_join = right.join()\n    if (left != [] && right != []){      \n      resp.push(left_join)\n      resp.push(right_join)\n    }\t\n  }\n  \n  if(resp.length > 0){    \n    return \"--readFilesIn \".concat(resp.join(\" \"))\n  }\n}"
              },
              "sbg:cmdInclude": true,
              "itemSeparator": " ",
              "separate": true
            },
            "label": "Read sequence",
            "id": "#reads",
            "sbg:fileTypes": "FASTA, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "sbg:category": "Basic"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "NotEqual",
                  "Equal"
                ],
                "name": "readMatesLengthsIn",
                "type": "enum"
              }
            ],
            "label": "Reads lengths",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--readMatesLengthsIn"
            },
            "sbg:toolDefaultValue": "NotEqual",
            "description": "Equal/Not equal - lengths of names, sequences, qualities for both mates are the same/not the same. \"Not equal\" is safe in all situations.",
            "id": "#readMatesLengthsIn",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Reads to map",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--readMapNumber"
            },
            "sbg:toolDefaultValue": "-1",
            "description": "Number of reads to map from the beginning of the file.",
            "id": "#readMapNumber",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Junctions max number",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitOutSJoneRead"
            },
            "sbg:toolDefaultValue": "1000",
            "description": "Max number of junctions for one read (including all multi-mappers).",
            "id": "#limitOutSJoneRead",
            "sbg:category": "Limits"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Collapsed junctions max number",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitOutSJcollapsed"
            },
            "sbg:toolDefaultValue": "1000000",
            "description": "Max number of collapsed junctions.",
            "id": "#limitOutSJcollapsed",
            "sbg:category": "Limits"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Fastx"
                ],
                "name": "outReadsUnmapped",
                "type": "enum"
              }
            ],
            "label": "Output unmapped reads",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outReadsUnmapped"
            },
            "sbg:toolDefaultValue": "None",
            "description": "Output of unmapped reads (besides SAM). None: no output; Fastx: output in separate fasta/fastq files, Unmapped.out.mate1/2.",
            "id": "#outReadsUnmapped",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Quality conversion",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outQSconversionAdd"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Add this number to the quality score (e.g. to convert from Illumina to Sanger, use -31).",
            "id": "#outQSconversionAdd",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "SAM",
                  "BAM"
                ],
                "name": "outSAMtype",
                "type": "enum"
              }
            ],
            "label": "Output format",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "{\n  SAM_type = $job.inputs.outSAMtype\n  SORT_type = $job.inputs.outSortingType\n  if (SAM_type && SORT_type) {\n    return \"--outSAMtype \".concat(SAM_type, \" \", SORT_type)\n  } else if (SAM_type && SORT_type == null) {\n    return \"--outSAMtype \".concat(SAM_type, \" Unsorted\")\n  }\n}"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "sbg:toolDefaultValue": "SAM",
            "description": "Format of output alignments.",
            "id": "#outSAMtype",
            "sbg:category": "Output"
          },
          {
            "id": "#outSortingType",
            "type": [
              "null",
              {
                "symbols": [
                  "Unsorted",
                  "SortedByCoordinate",
                  "Unsorted SortedByCoordinate"
                ],
                "name": "outSortingType",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "SortedByCoordinate",
            "description": "Type of output sorting.",
            "label": "Output sorting type",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Full",
                  "NoQS"
                ],
                "name": "outSAMmode",
                "type": "enum"
              }
            ],
            "label": "SAM mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMmode"
            },
            "sbg:toolDefaultValue": "Full",
            "description": "Mode of SAM output. Full: full SAM output; NoQS: full SAM but without quality scores.",
            "id": "#outSAMmode",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "intronMotif"
                ],
                "name": "outSAMstrandField",
                "type": "enum"
              }
            ],
            "label": "Strand field flag",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMstrandField"
            },
            "sbg:toolDefaultValue": "None",
            "description": "Cufflinks-like strand field flag. None: not used; intronMotif: strand derived from the intron motif. Reads with inconsistent and/or non-canonical introns are filtered out.",
            "id": "#outSAMstrandField",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "NH",
                  "All",
                  "None"
                ],
                "name": "outSAMattributes",
                "type": "enum"
              }
            ],
            "label": "SAM attributes",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMattributes"
            },
            "sbg:toolDefaultValue": "Standard",
            "description": "Desired SAM attributes, in the order desired for the output SAM. NH: any combination in any order; Standard: NH HI AS nM; All: NH HI AS nM NM MD jM jI; None: no attributes.",
            "id": "#outSAMattributes",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Within"
                ],
                "name": "outSAMunmapped",
                "type": "enum"
              }
            ],
            "label": "Write unmapped in SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMunmapped"
            },
            "sbg:toolDefaultValue": "None",
            "description": "Output of unmapped reads in the SAM format. None: no output Within: output unmapped reads within the main SAM file (i.e. Aligned.out.sam).",
            "id": "#outSAMunmapped",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Paired",
                  "PairedKeepInputOrder"
                ],
                "name": "outSAMorder",
                "type": "enum"
              }
            ],
            "label": "Sorting in SAM",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMorder"
            },
            "sbg:toolDefaultValue": "Paired",
            "description": "Type of sorting for the SAM output. Paired: one mate after the other for all paired alignments; PairedKeepInputOrder: one mate after the other for all paired alignments, the order is kept the same as in the input FASTQ files.",
            "id": "#outSAMorder",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "OneBestScore",
                  "AllBestScore"
                ],
                "name": "outSAMprimaryFlag",
                "type": "enum"
              }
            ],
            "label": "Primary alignments",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMprimaryFlag"
            },
            "sbg:toolDefaultValue": "OneBestScore",
            "description": "Which alignments are considered primary - all others will be marked with 0x100 bit in the FLAG. OneBestScore: only one alignment with the best score is primary; AllBestScore: all alignments with the best score are primary.",
            "id": "#outSAMprimaryFlag",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Standard",
                  "Number"
                ],
                "name": "outSAMreadID",
                "type": "enum"
              }
            ],
            "label": "Read ID",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMreadID"
            },
            "sbg:toolDefaultValue": "Standard",
            "description": "Read ID record type. Standard: first word (until space) from the FASTx read ID line, removing /1,/2 from the end; Number: read number (index) in the FASTx file.",
            "id": "#outSAMreadID",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "MAPQ value",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMmapqUnique"
            },
            "sbg:toolDefaultValue": "255",
            "description": "MAPQ value for unique mappers (0 to 255).",
            "id": "#outSAMmapqUnique",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "OR SAM flag",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMflagOR"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Set specific bits of the SAM FLAG.",
            "id": "#outSAMflagOR",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "AND SAM flag",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMflagAND"
            },
            "sbg:toolDefaultValue": "65535",
            "description": "Set specific bits of the SAM FLAG.",
            "id": "#outSAMflagAND",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "string"
            ],
            "label": "SAM header @HD",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMheaderHD"
            },
            "sbg:toolDefaultValue": "-",
            "description": "@HD (header) line of the SAM header.",
            "id": "#outSAMheaderHD",
            "sbg:category": "Output"
          },
          {
            "type": [
              "null",
              "string"
            ],
            "label": "SAM header @PG",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSAMheaderPG"
            },
            "sbg:toolDefaultValue": "-",
            "description": "Extra @PG (software) line of the SAM header (in addition to STAR).",
            "id": "#outSAMheaderPG",
            "sbg:category": "Output"
          },
          {
            "id": "#rg_seq_center",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the sequencing center for RG line.",
            "label": "Sequencing center",
            "sbg:category": "Read group"
          },
          {
            "id": "#rg_library_id",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the library ID for RG line.",
            "label": "Library ID",
            "sbg:category": "Read group"
          },
          {
            "id": "#rg_mfl",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the median fragment length for RG line.",
            "label": "Median fragment length",
            "sbg:category": "Read group"
          },
          {
            "id": "#rg_platform",
            "type": [
              "null",
              {
                "symbols": [
                  "LS 454",
                  "Helicos",
                  "Illumina",
                  "ABI SOLiD",
                  "Ion Torrent PGM",
                  "PacBio"
                ],
                "name": "rg_platform",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the version of the technology that was used for sequencing or assaying.",
            "label": "Platform",
            "sbg:category": "Read group"
          },
          {
            "id": "#rg_platform_unit_id",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the platform unit ID for RG line.",
            "label": "Platform unit ID",
            "sbg:category": "Read group"
          },
          {
            "id": "#rg_sample_id",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "Inferred from metadata",
            "description": "Specify the sample ID for RG line.",
            "label": "Sample ID",
            "sbg:category": "Read group"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Normal",
                  "BySJout"
                ],
                "name": "outFilterType",
                "type": "enum"
              }
            ],
            "label": "Filtering type",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterType"
            },
            "sbg:toolDefaultValue": "Normal",
            "description": "Type of filtering. Normal: standard filtering using only current alignment; BySJout: keep only those reads that contain junctions that passed filtering into SJ.out.tab.",
            "id": "#outFilterType",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Multimapping score range",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMultimapScoreRange"
            },
            "sbg:toolDefaultValue": "1",
            "description": "The score range below the maximum score for multimapping alignments.",
            "id": "#outFilterMultimapScoreRange",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max number of mappings",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMultimapNmax"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Read alignments will be output only if the read maps fewer than this value, otherwise no alignments will be output.",
            "id": "#outFilterMultimapNmax",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max number of mismatches",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNmax"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Alignment will be output only if it has fewer mismatches than this value.",
            "id": "#outFilterMismatchNmax",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Mismatches to *mapped* length",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNoverLmax"
            },
            "sbg:toolDefaultValue": "0.3",
            "description": "Alignment will be output only if its ratio of mismatches to *mapped* length is less than this value.",
            "id": "#outFilterMismatchNoverLmax",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Mismatches to *read* length",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMismatchNoverReadLmax"
            },
            "sbg:toolDefaultValue": "1",
            "description": "Alignment will be output only if its ratio of mismatches to *read* length is less than this value.",
            "id": "#outFilterMismatchNoverReadLmax",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min score",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterScoreMin"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Alignment will be output only if its score is higher than this value.",
            "id": "#outFilterScoreMin",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Min score normalized",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterScoreMinOverLread"
            },
            "sbg:toolDefaultValue": "0.66",
            "description": "'Minimum score' normalized to read length (sum of mates' lengths for paired-end reads).",
            "id": "#outFilterScoreMinOverLread",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min matched bases",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMatchNmin"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Alignment will be output only if the number of matched bases is higher than this value.",
            "id": "#outFilterMatchNmin",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Min matched bases normalized",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterMatchNminOverLread"
            },
            "sbg:toolDefaultValue": "0.66",
            "description": "'Minimum matched bases' normalized to read length (sum of mates lengths for paired-end reads).",
            "id": "#outFilterMatchNminOverLread",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "RemoveNoncanonical",
                  "RemoveNoncanonicalUnannotated"
                ],
                "name": "outFilterIntronMotifs",
                "type": "enum"
              }
            ],
            "label": "Motifs filtering",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outFilterIntronMotifs"
            },
            "sbg:toolDefaultValue": "None",
            "description": "Filter alignment using their motifs. None: no filtering; RemoveNoncanonical: filter out alignments that contain non-canonical junctions; RemoveNoncanonicalUnannotated: filter out alignments that contain non-canonical unannotated junctions when using annotated splice junctions database. The annotated non-canonical junctions will be kept.",
            "id": "#outFilterIntronMotifs",
            "sbg:category": "Output filtering"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "All",
                  "Unique"
                ],
                "name": "outSJfilterReads",
                "type": "enum"
              }
            ],
            "label": "Collapsed junctions reads",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--outSJfilterReads"
            },
            "sbg:toolDefaultValue": "All",
            "description": "Which reads to consider for collapsed splice junctions output. All: all reads, unique- and multi-mappers; Unique: uniquely mapping reads only.",
            "id": "#outSJfilterReads",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Min overhang SJ",
            "inputBinding": {
              "separate": true,
              "prefix": "--outSJfilterOverhangMin",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "30 12 12 12",
            "description": "Minimum overhang length for splice junctions on both sides for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Does not apply to annotated junctions.",
            "id": "#outSJfilterOverhangMin",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Min unique count",
            "inputBinding": {
              "separate": true,
              "prefix": "--outSJfilterCountUniqueMin",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "3 1 1 1",
            "description": "Minimum uniquely mapping read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "id": "#outSJfilterCountUniqueMin",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Min total count",
            "inputBinding": {
              "separate": true,
              "prefix": "--outSJfilterCountTotalMin",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "3 1 1 1",
            "description": "Minimum total (multi-mapping+unique) read count per junction for each of the motifs. To set no output for desired motif, assign -1 to the corresponding field. Junctions are output if one of --outSJfilterCountUniqueMin OR --outSJfilterCountTotalMin conditions are satisfied. Does not apply to annotated junctions.",
            "id": "#outSJfilterCountTotalMin",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Min distance to other donor/acceptor",
            "inputBinding": {
              "separate": true,
              "prefix": "--outSJfilterDistToOtherSJmin",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "10 0 5 10",
            "description": "Minimum allowed distance to other junctions' donor/acceptor for each of the motifs (int >= 0). Does not apply to annotated junctions.",
            "id": "#outSJfilterDistToOtherSJmin",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Max gap allowed",
            "inputBinding": {
              "separate": true,
              "prefix": "--outSJfilterIntronMaxVsReadN",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "50000 100000 200000",
            "description": "Maximum gap allowed for junctions supported by 1,2,3...N reads (int >= 0) i.e. by default junctions supported by 1 read can have gaps <=50000b, by 2 reads: <=100000b, by 3 reads: <=200000. By 4 or more reads: any gap <=alignIntronMax. Does not apply to annotated junctions.",
            "id": "#outSJfilterIntronMaxVsReadN",
            "sbg:category": "Output filtering: splice junctions"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Gap open penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGap"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Gap open penalty.",
            "id": "#scoreGap",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Non-canonical gap open",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapNoncan"
            },
            "sbg:toolDefaultValue": "-8",
            "description": "Non-canonical gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapNoncan",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "GC/AG and CT/GC gap open",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapGCAG"
            },
            "sbg:toolDefaultValue": "-4",
            "description": "GC/AG and CT/GC gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapGCAG",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "AT/AC and GT/AT gap open",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGapATAC"
            },
            "sbg:toolDefaultValue": "-8",
            "description": "AT/AC and GT/AT gap open penalty (in addition to --scoreGap).",
            "id": "#scoreGapATAC",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Log scaled score",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreGenomicLengthLog2scale"
            },
            "sbg:toolDefaultValue": "-0.25",
            "description": "Extra score logarithmically scaled with genomic length of the alignment: <int>*log2(genomicLength).",
            "id": "#scoreGenomicLengthLog2scale",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Deletion open penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreDelOpen"
            },
            "sbg:toolDefaultValue": "-2",
            "description": "Deletion open penalty.",
            "id": "#scoreDelOpen",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Deletion extension penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreDelBase"
            },
            "sbg:toolDefaultValue": "-2",
            "description": "Deletion extension penalty per base (in addition to --scoreDelOpen).",
            "id": "#scoreDelBase",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Insertion Open Penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreInsOpen"
            },
            "sbg:toolDefaultValue": "-2",
            "description": "Insertion open penalty.",
            "id": "#scoreInsOpen",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Insertion extension penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreInsBase"
            },
            "sbg:toolDefaultValue": "-2",
            "description": "Insertion extension penalty per base (in addition to --scoreInsOpen).",
            "id": "#scoreInsBase",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max score reduction",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--scoreStitchSJshift"
            },
            "sbg:toolDefaultValue": "1",
            "description": "Maximum score reduction while searching for SJ boundaries in the stitching step.",
            "id": "#scoreStitchSJshift",
            "sbg:category": "Scoring"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Search start point",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchStartLmax"
            },
            "sbg:toolDefaultValue": "50",
            "description": "Defines the search start point through the read - the read is split into pieces no longer than this value (int>0).",
            "id": "#seedSearchStartLmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Search start point normalized",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchStartLmaxOverLread"
            },
            "sbg:toolDefaultValue": "1.0",
            "description": "SeedSearchStartLmax normalized to read length (sum of mates' lengths for paired-end reads).",
            "id": "#seedSearchStartLmaxOverLread",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max seed length",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedSearchLmax"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Defines the maximum length of the seeds, if =0 max seed length is infinite (int>=0).",
            "id": "#seedSearchLmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Filter pieces for stitching",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedMultimapNmax"
            },
            "sbg:toolDefaultValue": "10000",
            "description": "Only pieces that map fewer than this value are utilized in the stitching procedure (int>=0).",
            "id": "#seedMultimapNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max seeds per read",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedPerReadNmax"
            },
            "sbg:toolDefaultValue": "1000",
            "description": "Max number of seeds per read (int>=0).",
            "id": "#seedPerReadNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max seeds per window",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedPerWindowNmax"
            },
            "sbg:toolDefaultValue": "50",
            "description": "Max number of seeds per window (int>=0).",
            "id": "#seedPerWindowNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max one-seed loci per window",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--seedNoneLociPerWindow"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Max number of one seed loci per window (int>=0).",
            "id": "#seedNoneLociPerWindow",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min intron size",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignIntronMin"
            },
            "sbg:toolDefaultValue": "21",
            "description": "Minimum intron size: genomic gap is considered intron if its length >= alignIntronMin, otherwise it is considered Deletion (int>=0).",
            "id": "#alignIntronMin",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max intron size",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignIntronMax"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Maximum intron size, if 0, max intron size will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "id": "#alignIntronMax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max mates gap",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignMatesGapMax"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Maximum gap between two mates, if 0, max intron gap will be determined by (2^winBinNbits)*winAnchorDistNbins.",
            "id": "#alignMatesGapMax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min overhang",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSJoverhangMin"
            },
            "sbg:toolDefaultValue": "5",
            "description": "Minimum overhang (i.e. block size) for spliced alignments (int>0).",
            "id": "#alignSJoverhangMin",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min overhang: annotated",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSJDBoverhangMin"
            },
            "sbg:toolDefaultValue": "3",
            "description": "Minimum overhang (i.e. block size) for annotated (sjdb) spliced alignments (int>0).",
            "id": "#alignSJDBoverhangMin",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min mapped length",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSplicedMateMapLmin"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Minimum mapped length for a read mate that is spliced (int>0).",
            "id": "#alignSplicedMateMapLmin",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Min mapped length normalized",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSplicedMateMapLminOverLmate"
            },
            "sbg:toolDefaultValue": "0.66",
            "description": "AlignSplicedMateMapLmin normalized to mate length (float>0).",
            "id": "#alignSplicedMateMapLminOverLmate",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "float"
            ],
            "label": "Max windows per read",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignWindowsPerReadNmax"
            },
            "sbg:toolDefaultValue": "10000",
            "description": "Max number of windows per read (int>0).",
            "id": "#alignWindowsPerReadNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max transcripts per window",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignTranscriptsPerWindowNmax"
            },
            "sbg:toolDefaultValue": "100",
            "description": "Max number of transcripts per window (int>0).",
            "id": "#alignTranscriptsPerWindowNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max transcripts per read",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignTranscriptsPerReadNmax"
            },
            "sbg:toolDefaultValue": "10000",
            "description": "Max number of different alignments per read to consider (int>0).",
            "id": "#alignTranscriptsPerReadNmax",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Local",
                  "EndToEnd",
                  "Extend5pOfRead1"
                ],
                "name": "alignEndsType",
                "type": "enum"
              }
            ],
            "label": "Alignment type",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignEndsType"
            },
            "sbg:toolDefaultValue": "Local",
            "description": "Type of read ends alignment. Local: standard local alignment with soft-clipping allowed. EndToEnd: force end to end read alignment, do not soft-clip.",
            "id": "#alignEndsType",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "Yes",
                  "No"
                ],
                "name": "alignSoftClipAtReferenceEnds",
                "type": "enum"
              }
            ],
            "label": "Soft clipping",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--alignSoftClipAtReferenceEnds"
            },
            "sbg:toolDefaultValue": "Yes",
            "description": "Option which allows soft clipping of alignments at the reference (chromosome) ends. Can be disabled for compatibility with Cufflinks/Cuffmerge. Yes: Enables soft clipping; No: Disables soft clipping.",
            "id": "#alignSoftClipAtReferenceEnds",
            "sbg:category": "Alignments and Seeding"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max loci anchors",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winAnchorMultimapNmax"
            },
            "sbg:toolDefaultValue": "50",
            "description": "Max number of loci anchors are allowed to map to (int>0).",
            "id": "#winAnchorMultimapNmax",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Bin size",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winBinNbits"
            },
            "sbg:toolDefaultValue": "16",
            "description": "=log2(winBin), where winBin is the size of the bin for the windows/clustering, each window will occupy an integer number of bins (int>0).",
            "id": "#winBinNbits",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max bins between anchors",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winAnchorDistNbins"
            },
            "sbg:toolDefaultValue": "9",
            "description": "Max number of bins between two anchors that allows aggregation of anchors into one window (int>0).",
            "id": "#winAnchorDistNbins",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Flanking regions size",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--winFlankNbins"
            },
            "sbg:toolDefaultValue": "4",
            "description": "=log2(winFlank), where win Flank is the size of the left and right flanking regions for each window (int>0).",
            "id": "#winFlankNbins",
            "sbg:category": "Windows, Anchors, Binning"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min segment length",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimSegmentMin"
            },
            "sbg:toolDefaultValue": "15",
            "description": "Minimum length of chimeric segment length, if =0, no chimeric output (int>=0).",
            "id": "#chimSegmentMin",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min total score",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreMin"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Minimum total (summed) score of the chimeric segments (int>=0).",
            "id": "#chimScoreMin",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max drop score",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreDropMax"
            },
            "sbg:toolDefaultValue": "20",
            "description": "Max drop (difference) of chimeric score (the sum of scores of all chimeric segements) from the read length (int>=0).",
            "id": "#chimScoreDropMax",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min separation score",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreSeparation"
            },
            "sbg:toolDefaultValue": "10",
            "description": "Minimum difference (separation) between the best chimeric score and the next one (int>=0).",
            "id": "#chimScoreSeparation",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Non-GT/AG penalty",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimScoreJunctionNonGTAG"
            },
            "sbg:toolDefaultValue": "-1",
            "description": "Penalty for a non-GT/AG chimeric junction.",
            "id": "#chimScoreJunctionNonGTAG",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Min junction overhang",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--chimJunctionOverhangMin"
            },
            "sbg:toolDefaultValue": "20",
            "description": "Minimum overhang for a chimeric junction (int>=0).",
            "id": "#chimJunctionOverhangMin",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "id": "#quantMode",
            "type": [
              "null",
              {
                "symbols": [
                  "TranscriptomeSAM",
                  "GeneCounts",
                  "TranscriptomeSAM GeneCounts"
                ],
                "name": "quantMode",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "-",
            "description": "Types of quantification requested. 'TranscriptomeSAM' option outputs SAM/BAM alignments to transcriptome into a separate file. With 'GeneCounts' option, STAR will count number of reads per gene while mapping.",
            "label": "Quantification mode",
            "sbg:category": "Quantification of Annotations"
          },
          {
            "id": "#twopass1readsN",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "-1",
            "description": "Number of reads to process for the 1st step. 0: 1-step only, no 2nd pass; use very large number to map all reads in the first step (int>0).",
            "label": "Reads to process in 1st step",
            "sbg:category": "2-pass mapping"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "None",
                  "Basic"
                ],
                "name": "twopassMode",
                "type": "enum"
              }
            ],
            "label": "Two-pass mode",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--twopassMode"
            },
            "sbg:toolDefaultValue": "None",
            "description": "2-pass mapping mode. None: 1-pass mapping; Basic: basic 2-pass mapping, with all 1st pass junctions inserted into the genome indices on the fly.",
            "id": "#twopassMode",
            "sbg:category": "2-pass mapping"
          },
          {
            "type": [
              "null",
              "string"
            ],
            "label": "Genome dir name",
            "inputBinding": {
              "position": 0,
              "valueFrom": {
                "class": "Expression",
                "engine": "#cwl-js-engine",
                "script": "$job.inputs.genomeDirName || \"genomeDir\""
              },
              "sbg:cmdInclude": true,
              "prefix": "--genomeDir",
              "separate": true
            },
            "sbg:toolDefaultValue": "genomeDir",
            "description": "Name of the directory which contains genome files (when genome.tar is uncompressed).",
            "id": "#genomeDirName",
            "sbg:category": "Basic"
          },
          {
            "id": "#sjdbInsertSave",
            "type": [
              "null",
              {
                "symbols": [
                  "Basic",
                  "All",
                  "None"
                ],
                "name": "sjdbInsertSave",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "None",
            "description": "Which files to save when sjdb junctions are inserted on the fly at the mapping step. None: not saving files at all; Basic: only small junction/transcript files; All: all files including big Genome, SA and SAindex. These files are output as archive.",
            "label": "Save junction files",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbGTFchrPrefix",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "-",
            "description": "Prefix for chromosome names in a GTF file (e.g. 'chr' for using ENSMEBL annotations with UCSC geneomes).",
            "label": "Chromosome names",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbGTFfeatureExon",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "exon",
            "description": "Feature type in GTF file to be used as exons for building transcripts.",
            "label": "Set exons feature",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbGTFtagExonParentTranscript",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "transcript_id",
            "description": "Tag name to be used as exons\u2019 transcript-parents.",
            "label": "Exons' parents name",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbGTFtagExonParentGene",
            "type": [
              "null",
              "string"
            ],
            "sbg:toolDefaultValue": "gene_id",
            "description": "Tag name to be used as exons\u2019 gene-parents.",
            "label": "Gene name",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbOverhang",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "100",
            "description": "Length of the donor/acceptor sequence on each side of the junctions, ideally = (mate_length - 1) (int >= 0), if int = 0, splice junction database is not used.",
            "label": "\"Overhang\" length",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbScore",
            "type": [
              "null",
              "int"
            ],
            "sbg:toolDefaultValue": "2",
            "description": "Extra alignment score for alignments that cross database junctions.",
            "label": "Extra alignment score",
            "sbg:category": "Splice junctions database"
          },
          {
            "id": "#sjdbGTFfile",
            "type": [
              "null",
              {
                "items": "File",
                "type": "array"
              }
            ],
            "sbg:fileTypes": "GTF, GFF, TXT",
            "description": "Gene model annotations and/or known transcripts. No need to include this input, except in case of using \"on the fly\" annotations.",
            "label": "Splice junction file",
            "sbg:category": "Basic"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Clip 3p bases",
            "inputBinding": {
              "separate": true,
              "prefix": "--clip3pNbases",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "0",
            "description": "Number of bases to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pNbases",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "type": "array"
              }
            ],
            "label": "Clip 5p bases",
            "inputBinding": {
              "separate": true,
              "prefix": "--clip5pNbases",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "0",
            "description": "Number of bases to clip from 5p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip5pNbases",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              {
                "items": "string",
                "type": "array"
              }
            ],
            "label": "Clip 3p adapter sequence",
            "inputBinding": {
              "separate": true,
              "prefix": "--clip3pAdapterSeq",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "-",
            "description": "Adapter sequence to clip from 3p of each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAdapterSeq",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              {
                "items": "float",
                "type": "array"
              }
            ],
            "label": "Max mismatches proportions",
            "inputBinding": {
              "separate": true,
              "prefix": "--clip3pAdapterMMp",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "0.1",
            "description": "Max proportion of mismatches for 3p adapter clipping for each mate. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAdapterMMp",
            "sbg:category": "Read parameters"
          },
          {
            "type": [
              "null",
              {
                "items": "int",
                "name": "clip3pAfterAdapterNbases",
                "type": "array"
              }
            ],
            "label": "Clip 3p after adapter seq",
            "inputBinding": {
              "separate": true,
              "prefix": "--clip3pAfterAdapterNbases",
              "itemSeparator": " ",
              "sbg:cmdInclude": true
            },
            "sbg:toolDefaultValue": "0",
            "description": "Number of bases to clip from 3p of each mate after the adapter clipping. In case only one value is given, it will be assumed the same for both mates.",
            "id": "#clip3pAfterAdapterNbases",
            "sbg:category": "Read parameters"
          },
          {
            "id": "#chimOutType",
            "type": [
              "null",
              {
                "symbols": [
                  "SeparateSAMold",
                  "Within"
                ],
                "name": "chimOutType",
                "type": "enum"
              }
            ],
            "sbg:toolDefaultValue": "SeparateSAMold",
            "description": "Type of chimeric output. SeparateSAMold: output old SAM into separate Chimeric.out.sam file; Within: output into main aligned SAM/BAM files.",
            "label": "Chimeric output type",
            "sbg:category": "Chimeric Alignments"
          },
          {
            "id": "#genome",
            "type": [
              "File"
            ],
            "sbg:fileTypes": "TAR",
            "description": "Genome files created using STAR Genome Generate.",
            "label": "Genome files",
            "sbg:category": "Basic"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Max insert junctions",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitSjdbInsertNsj"
            },
            "sbg:toolDefaultValue": "1000000",
            "description": "Maximum number of junction to be inserted to the genome on the fly at the mapping stage, including those from annotations and those detected in the 1st step of the 2-pass run.",
            "id": "#limitSjdbInsertNsj",
            "sbg:category": "Limits"
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "IndelSoftclipSingleend",
                  "Singleend"
                ],
                "name": "quantTranscriptomeBan",
                "type": "enum"
              }
            ],
            "label": "Prohibit alignment type",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--quantTranscriptomeBan"
            },
            "sbg:toolDefaultValue": "IndelSoftclipSingleend",
            "description": "Prohibit various alignment type. IndelSoftclipSingleend: prohibit indels, soft clipping and single-end alignments - compatible with RSEM; Singleend: prohibit single-end alignments.",
            "id": "#quantTranscriptomeBan",
            "sbg:category": "Quantification of Annotations"
          },
          {
            "type": [
              "null",
              "int"
            ],
            "label": "Limit BAM sorting memory",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--limitBAMsortRAM"
            },
            "sbg:toolDefaultValue": "0",
            "description": "Maximum available RAM for sorting BAM. If set to 0, it will be set to the genome index size.",
            "id": "#limitBAMsortRAM",
            "sbg:category": "Limits"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:revision": 0,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799778
          },
          {
            "sbg:revision": 1,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799780
          },
          {
            "sbg:revision": 2,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799782
          },
          {
            "sbg:revision": 3,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1462904151
          },
          {
            "sbg:revision": 4,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1462904151
          },
          {
            "sbg:revision": 5,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1465231634
          },
          {
            "sbg:revision": 6,
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1465231636
          },
          {
            "sbg:revision": 7,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471539440
          },
          {
            "sbg:revision": 8,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471539440
          },
          {
            "sbg:revision": 9,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471539440
          },
          {
            "sbg:revision": 10,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471539440
          },
          {
            "sbg:revision": 11,
            "sbg:modifiedBy": "admin",
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1471539440
          }
        ],
        "hints": [
          {
            "dockerPull": "images.sbgenomics.com/ana_d/star:2.4.2a",
            "class": "DockerRequirement",
            "dockerImageId": "a4b0ad2c3cae"
          },
          {
            "value": 60000,
            "class": "sbg:MemRequirement"
          },
          {
            "value": 15,
            "class": "sbg:CPURequirement"
          }
        ],
        "description": "STAR is an ultrafast universal RNA-seq aligner. It has very high mapping speed, accurate alignment of contiguous and spliced reads, detection of polyA-tails, non-canonical splices and chimeric (fusion) junctions. It works with reads starting from lengths ~15 bases up to ~300 bases. In case of having longer reads, use of STAR Long is recommended.\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "requirements": [
          {
            "requirements": [
              {
                "dockerPull": "rabix/js-engine",
                "class": "DockerRequirement"
              }
            ],
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement"
          }
        ],
        "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/star/11/raw/",
        "sbg:license": "GNU General Public License v3.0 only",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  file = [].concat($job.inputs.reads)[0].path\n  extension = /(?:\\.([^.]+))?$/.exec(file)[1]\n  if (extension == \"gz\") {\n    return \"--readFilesCommand zcat\"\n  } else if (extension == \"bz2\") {\n    return \"--readFilesCommand bzcat\"\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\t\n  var sjFormat = \"False\"\n  var gtfgffFormat = \"False\"\n  var list = $job.inputs.sjdbGTFfile\n  var paths_list = []\n  var joined_paths = \"\"\n  \n  if (list) {\n    list.forEach(function(f){return paths_list.push(f.path)})\n    joined_paths = paths_list.join(\" \")\n\n\n    paths_list.forEach(function(f){\n      ext = f.replace(/^.*\\./, '')\n      if (ext == \"gff\" || ext == \"gtf\") {\n        gtfgffFormat = \"True\"\n        return gtfgffFormat\n      }\n      if (ext == \"txt\") {\n        sjFormat = \"True\"\n        return sjFormat\n      }\n    })\n\n    if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave != \"None\") {\n      if (sjFormat == \"True\") {\n        return \"--sjdbFileChrStartEnd \".concat(joined_paths)\n      }\n      else if (gtfgffFormat == \"True\") {\n        return \"--sjdbGTFfile \".concat(joined_paths)\n      }\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  a = b = c = d = e = f = g = []\n  if ($job.inputs.sjdbGTFchrPrefix) {\n    a = [\"--sjdbGTFchrPrefix\", $job.inputs.sjdbGTFchrPrefix]\n  }\n  if ($job.inputs.sjdbGTFfeatureExon) {\n    b = [\"--sjdbGTFfeatureExon\", $job.inputs.sjdbGTFfeatureExon]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentTranscript) {\n    c = [\"--sjdbGTFtagExonParentTranscript\", $job.inputs.sjdbGTFtagExonParentTranscript]\n  }\n  if ($job.inputs.sjdbGTFtagExonParentGene) {\n    d = [\"--sjdbGTFtagExonParentGene\", $job.inputs.sjdbGTFtagExonParentGene]\n  }\n  if ($job.inputs.sjdbOverhang) {\n    e = [\"--sjdbOverhang\", $job.inputs.sjdbOverhang]\n  }\n  if ($job.inputs.sjdbScore) {\n    f = [\"--sjdbScore\", $job.inputs.sjdbScore]\n  }\n  if ($job.inputs.sjdbInsertSave) {\n    g = [\"--sjdbInsertSave\", $job.inputs.sjdbInsertSave]\n  }\n  \n  \n  \n  if ($job.inputs.sjdbInsertSave != \"None\" && $job.inputs.sjdbGTFfile) {\n    new_list = a.concat(b, c, d, e, f, g)\n    return new_list.join(\" \")\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  if ($job.inputs.twopassMode == \"Basic\") {\n    if ($job.inputs.twopass1readsN) {\n      return \"--twopass1readsN \".concat($job.inputs.twopass1readsN) \n    } else {\n      return \"--twopass1readsN -1\"\n    }\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  if ($job.inputs.chimOutType == \"Within\") {\n    return \"--chimOutType \".concat(\"Within\", $job.inputs.outSAMtype)\n  }\n  else {\n    return \"--chimOutType SeparateSAMold\"\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  var param_list = []\n  \n  function add_param(key, value){\n    if (value == \"\") {\n      return\n    }\n    else {\n      return param_list.push(key.concat(\":\", value))\n    }\n  }\n  \n  add_param('ID', \"1\")\n  if ($job.inputs.rg_seq_center) {\n    add_param('CN', $job.inputs.rg_seq_center)\n  } else if ([].concat($job.inputs.reads)[0].metadata.seq_center) {\n    add_param('CN', [].concat($job.inputs.reads)[0].metadata.seq_center)\n  }\n  if ($job.inputs.rg_library_id) {\n    add_param('LB', $job.inputs.rg_library_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.library_id) {\n    add_param('LB', [].concat($job.inputs.reads)[0].metadata.library_id)\n  }\n  if ($job.inputs.rg_mfl) {\n    add_param('PI', $job.inputs.rg_mfl)\n  } else if ([].concat($job.inputs.reads)[0].metadata.median_fragment_length) {\n    add_param('PI', [].concat($job.inputs.reads)[0].metadata.median_fragment_length)\n  }\n  if ($job.inputs.rg_platform) {\n    add_param('PL', $job.inputs.rg_platform.replace(/ /g,\"_\"))\n  } else if ([].concat($job.inputs.reads)[0].metadata.platform) {\n    add_param('PL', [].concat($job.inputs.reads)[0].metadata.platform.replace(/ /g,\"_\"))\n  }\n  if ($job.inputs.rg_platform_unit_id) {\n    add_param('PU', $job.inputs.rg_platform_unit_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.platform_unit_id) {\n    add_param('PU', [].concat($job.inputs.reads)[0].metadata.platform_unit_id)\n  }\n  if ($job.inputs.rg_sample_id) {\n    add_param('SM', $job.inputs.rg_sample_id)\n  } else if ([].concat($job.inputs.reads)[0].metadata.sample_id) {\n    add_param('SM', [].concat($job.inputs.reads)[0].metadata.sample_id)\n  }\n  return \"--outSAMattrRGline \".concat(param_list.join(\" \"))\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  if ($job.inputs.sjdbGTFfile && $job.inputs.quantMode) {\n    return \"--quantMode \".concat($job.inputs.quantMode)\n  }\n}"
            },
            "separate": true
          },
          {
            "position": 100,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  intermediate = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\"._STARgenome\")\n  source = \"./\".concat(intermediate)\n  destination = intermediate.concat(\".tar\")\n  if ($job.inputs.sjdbGTFfile && $job.inputs.sjdbInsertSave && $job.inputs.sjdbInsertSave != \"None\") {\n    return \"&& tar -vcf \".concat(destination, \" \", source)\n  }\n}"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\")\n}"
            },
            "prefix": "--outFileNamePrefix",
            "separate": true
          },
          {
            "position": 101,
            "valueFrom": {
              "class": "Expression",
              "engine": "#cwl-js-engine",
              "script": "{\n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  arr = [].concat($job.inputs.reads)\n  arr.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  common_prefix = sharedStart(path_list)\n  mate1 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate1\")\n  mate2 = common_prefix.replace( /\\-$|\\_$|\\.$/, '' ).concat(\".Unmapped.out.mate2\")\n  mate1fq = mate1.concat(\".fastq\")\n  mate2fq = mate2.concat(\".fastq\")\n  if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length > 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq, \" && mv \", mate2, \" \", mate2fq)\n  }\n  else if ($job.inputs.outReadsUnmapped == \"Fastx\" && arr.length == 1) {\n    return \"&& mv \".concat(mate1, \" \", mate1fq)\n  }\n}"
            },
            "separate": true
          }
        ],
        "stdout": "",
        "sbg:validationErrors": [],
        "baseCommand": [
          "tar",
          "-xvf",
          {
            "class": "Expression",
            "engine": "#cwl-js-engine",
            "script": "$job.inputs.genome.path"
          },
          "&&",
          "/opt/STAR",
          "--runThreadN",
          {
            "class": "Expression",
            "engine": "#cwl-js-engine",
            "script": "{\n  return $job.allocatedResources.cpu\n}"
          }
        ],
        "sbg:toolkitVersion": "2.4.2a",
        "stdin": "",
        "sbg:toolAuthor": "Alexander Dobin/CSHL",
        "sbg:project": "admin/sbg-public-data",
        "sbg:modifiedBy": "admin",
        "class": "CommandLineTool",
        "sbg:sbgMaintained": false,
        "sbg:toolkit": "STAR",
        "sbg:job": {
          "inputs": {
            "readMatesLengthsIn": "NotEqual",
            "sjdbScore": null,
            "rg_library_id": "",
            "chimScoreMin": 0,
            "alignSJoverhangMin": 0,
            "alignMatesGapMax": 0,
            "rg_seq_center": "",
            "alignTranscriptsPerWindowNmax": 0,
            "seedPerReadNmax": 0,
            "sjdbOverhang": null,
            "quantTranscriptomeBan": "IndelSoftclipSingleend",
            "seedSearchLmax": 0,
            "seedPerWindowNmax": 0,
            "scoreGapGCAG": 0,
            "outSJfilterIntronMaxVsReadN": [
              0
            ],
            "outFilterType": "Normal",
            "outSAMflagAND": 0,
            "winAnchorDistNbins": 0,
            "outReadsUnmapped": "Fastx",
            "outSAMtype": "BAM",
            "outSAMreadID": "Standard",
            "seedSearchStartLmaxOverLread": 0,
            "outSAMmapqUnique": 0,
            "scoreGap": 0,
            "limitBAMsortRAM": 0,
            "outSAMmode": "Full",
            "alignSplicedMateMapLmin": 0,
            "outSJfilterDistToOtherSJmin": [
              0
            ],
            "sjdbGTFchrPrefix": "chrPrefix",
            "sjdbInsertSave": "Basic",
            "sjdbGTFfeatureExon": "",
            "winBinNbits": 0,
            "alignEndsType": "Local",
            "alignWindowsPerReadNmax": 0,
            "alignSJDBoverhangMin": 0,
            "GENOME_DIR_NAME": "",
            "outSAMheaderPG": "outSAMheaderPG",
            "outFilterMultimapScoreRange": 0,
            "sjdbGTFtagExonParentGene": "",
            "outFilterMismatchNoverLmax": 0,
            "reads": [
              {
                "metadata": {
                  "format": "fastq",
                  "seq_center": "illumina",
                  "paired_end": "1"
                },
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/test-data/mate_1.fastq.bz2"
              }
            ],
            "outSAMheaderHD": "outSAMheaderHD",
            "rg_platform_unit_id": "rg_platform_unit",
            "scoreDelBase": 0,
            "alignIntronMax": 0,
            "scoreGapATAC": 0,
            "outFilterMultimapNmax": 0,
            "chimJunctionOverhangMin": 0,
            "twopassMode": "Basic",
            "scoreDelOpen": 0,
            "seedNoneLociPerWindow": 0,
            "seedMultimapNmax": 0,
            "scoreInsOpen": 0,
            "clip3pAdapterSeq": [
              "clip3pAdapterSeq"
            ],
            "quantMode": "TranscriptomeSAM",
            "genome": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": "genome.ext"
            },
            "outSAMflagOR": 0,
            "chimScoreDropMax": 0,
            "outFilterMismatchNmax": 0,
            "scoreInsBase": 0,
            "outFilterMismatchNoverReadLmax": 0,
            "scoreGenomicLengthLog2scale": 0,
            "outSJfilterOverhangMin": [
              30,
              12,
              12,
              12
            ],
            "outFilterScoreMinOverLread": 0,
            "chimSegmentMin": 0,
            "twopass1readsN": 0,
            "scoreStitchSJshift": 0,
            "outSAMprimaryFlag": "OneBestScore",
            "outSJfilterCountTotalMin": [
              3,
              1,
              1,
              1
            ],
            "rg_mfl": "rg_mfl",
            "limitOutSJcollapsed": 0,
            "outSJfilterCountUniqueMin": [
              3,
              1,
              1,
              1
            ],
            "outFilterIntronMotifs": "None",
            "chimOutType": "Within",
            "rg_platform": "Ion Torrent PGM",
            "scoreGapNoncan": 0,
            "alignTranscriptsPerReadNmax": 0,
            "alignSplicedMateMapLminOverLmate": 0,
            "winFlankNbins": 0,
            "limitSjdbInsertNsj": 0,
            "clip3pAfterAdapterNbases": [
              0
            ],
            "readMapNumber": 0,
            "chimScoreJunctionNonGTAG": 0,
            "alignSoftClipAtReferenceEnds": "Yes",
            "outFilterMatchNminOverLread": 0,
            "winAnchorMultimapNmax": 0,
            "outFilterMatchNmin": 0,
            "outSortingType": "Unsorted",
            "sjdbGTFfile": [
              {
                "path": "/demo/test-data/chr20.gtf"
              }
            ],
            "rg_sample_id": "rg_sample",
            "chimScoreSeparation": 0,
            "outSAMunmapped": "None",
            "sjdbGTFtagExonParentTranscript": "",
            "clip5pNbases": [
              0
            ],
            "clip3pNbases": [
              0,
              3
            ],
            "clip3pAdapterMMp": [
              0
            ],
            "outSAMattributes": "Standard",
            "outSJfilterReads": "All",
            "outQSconversionAdd": 0,
            "outFilterScoreMin": 0,
            "outSAMorder": "Paired",
            "limitOutSJoneRead": 0,
            "alignIntronMin": 0,
            "outSAMstrandField": "None",
            "seedSearchStartLmax": 0
          },
          "allocatedResources": {
            "mem": 60000,
            "cpu": 15
          }
        },
        "temporaryFailCodes": [],
        "sbg:latestRevision": 11,
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "sbg:links": [
          {
            "id": "https://github.com/alexdobin/STAR",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/alexdobin/STAR/releases",
            "label": "Releases"
          },
          {
            "id": "https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf",
            "label": "Manual"
          },
          {
            "id": "https://groups.google.com/forum/#!forum/rna-star",
            "label": "Support"
          },
          {
            "id": "http://www.ncbi.nlm.nih.gov/pubmed/23104886",
            "label": "Publication"
          }
        ],
        "sbg:revision": 11,
        "sbg:createdBy": "sevenbridges",
        "sbg:createdOn": 1453799778,
        "sbg:modifiedOn": 1471539440,
        "label": "STAR",
        "sbg:categories": [
          "Alignment"
        ]
      },
      "inputs": [
        {
          "source": [
            "#SBG_Flatten.flat"
          ],
          "id": "#STAR.reads"
        },
        {
          "id": "#STAR.readMatesLengthsIn"
        },
        {
          "id": "#STAR.readMapNumber"
        },
        {
          "id": "#STAR.limitOutSJoneRead"
        },
        {
          "id": "#STAR.limitOutSJcollapsed"
        },
        {
          "id": "#STAR.outReadsUnmapped",
          "default": "None"
        },
        {
          "id": "#STAR.outQSconversionAdd"
        },
        {
          "id": "#STAR.outSAMtype",
          "default": "BAM"
        },
        {
          "id": "#STAR.outSortingType",
          "default": "SortedByCoordinate"
        },
        {
          "id": "#STAR.outSAMmode"
        },
        {
          "id": "#STAR.outSAMstrandField"
        },
        {
          "id": "#STAR.outSAMattributes"
        },
        {
          "id": "#STAR.outSAMunmapped",
          "default": "None"
        },
        {
          "id": "#STAR.outSAMorder"
        },
        {
          "id": "#STAR.outSAMprimaryFlag"
        },
        {
          "id": "#STAR.outSAMreadID"
        },
        {
          "id": "#STAR.outSAMmapqUnique"
        },
        {
          "id": "#STAR.outSAMflagOR"
        },
        {
          "id": "#STAR.outSAMflagAND"
        },
        {
          "id": "#STAR.outSAMheaderHD"
        },
        {
          "id": "#STAR.outSAMheaderPG"
        },
        {
          "id": "#STAR.rg_seq_center",
          "default": "CGR"
        },
        {
          "id": "#STAR.rg_library_id"
        },
        {
          "id": "#STAR.rg_mfl"
        },
        {
          "id": "#STAR.rg_platform"
        },
        {
          "id": "#STAR.rg_platform_unit_id"
        },
        {
          "id": "#STAR.rg_sample_id"
        },
        {
          "id": "#STAR.outFilterType"
        },
        {
          "id": "#STAR.outFilterMultimapScoreRange"
        },
        {
          "id": "#STAR.outFilterMultimapNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverLmax"
        },
        {
          "id": "#STAR.outFilterMismatchNoverReadLmax"
        },
        {
          "id": "#STAR.outFilterScoreMin"
        },
        {
          "id": "#STAR.outFilterScoreMinOverLread"
        },
        {
          "id": "#STAR.outFilterMatchNmin"
        },
        {
          "id": "#STAR.outFilterMatchNminOverLread"
        },
        {
          "id": "#STAR.outFilterIntronMotifs"
        },
        {
          "id": "#STAR.outSJfilterReads"
        },
        {
          "id": "#STAR.outSJfilterOverhangMin"
        },
        {
          "id": "#STAR.outSJfilterCountUniqueMin"
        },
        {
          "id": "#STAR.outSJfilterCountTotalMin"
        },
        {
          "id": "#STAR.outSJfilterDistToOtherSJmin"
        },
        {
          "id": "#STAR.outSJfilterIntronMaxVsReadN"
        },
        {
          "id": "#STAR.scoreGap"
        },
        {
          "id": "#STAR.scoreGapNoncan"
        },
        {
          "id": "#STAR.scoreGapGCAG"
        },
        {
          "id": "#STAR.scoreGapATAC"
        },
        {
          "id": "#STAR.scoreGenomicLengthLog2scale"
        },
        {
          "id": "#STAR.scoreDelOpen"
        },
        {
          "id": "#STAR.scoreDelBase"
        },
        {
          "id": "#STAR.scoreInsOpen"
        },
        {
          "id": "#STAR.scoreInsBase"
        },
        {
          "id": "#STAR.scoreStitchSJshift"
        },
        {
          "id": "#STAR.seedSearchStartLmax"
        },
        {
          "id": "#STAR.seedSearchStartLmaxOverLread"
        },
        {
          "id": "#STAR.seedSearchLmax"
        },
        {
          "id": "#STAR.seedMultimapNmax"
        },
        {
          "id": "#STAR.seedPerReadNmax"
        },
        {
          "id": "#STAR.seedPerWindowNmax"
        },
        {
          "id": "#STAR.seedNoneLociPerWindow"
        },
        {
          "id": "#STAR.alignIntronMin"
        },
        {
          "id": "#STAR.alignIntronMax"
        },
        {
          "id": "#STAR.alignMatesGapMax"
        },
        {
          "id": "#STAR.alignSJoverhangMin"
        },
        {
          "id": "#STAR.alignSJDBoverhangMin"
        },
        {
          "id": "#STAR.alignSplicedMateMapLmin"
        },
        {
          "id": "#STAR.alignSplicedMateMapLminOverLmate"
        },
        {
          "id": "#STAR.alignWindowsPerReadNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerWindowNmax"
        },
        {
          "id": "#STAR.alignTranscriptsPerReadNmax"
        },
        {
          "id": "#STAR.alignEndsType"
        },
        {
          "id": "#STAR.alignSoftClipAtReferenceEnds"
        },
        {
          "id": "#STAR.winAnchorMultimapNmax"
        },
        {
          "id": "#STAR.winBinNbits"
        },
        {
          "id": "#STAR.winAnchorDistNbins"
        },
        {
          "id": "#STAR.winFlankNbins"
        },
        {
          "id": "#STAR.chimSegmentMin"
        },
        {
          "id": "#STAR.chimScoreMin"
        },
        {
          "id": "#STAR.chimScoreDropMax"
        },
        {
          "id": "#STAR.chimScoreSeparation"
        },
        {
          "id": "#STAR.chimScoreJunctionNonGTAG"
        },
        {
          "id": "#STAR.chimJunctionOverhangMin"
        },
        {
          "id": "#STAR.quantMode",
          "default": "TranscriptomeSAM"
        },
        {
          "id": "#STAR.twopass1readsN"
        },
        {
          "id": "#STAR.twopassMode",
          "default": "None"
        },
        {
          "id": "#STAR.genomeDirName"
        },
        {
          "id": "#STAR.sjdbInsertSave"
        },
        {
          "id": "#STAR.sjdbGTFchrPrefix"
        },
        {
          "id": "#STAR.sjdbGTFfeatureExon"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentTranscript"
        },
        {
          "id": "#STAR.sjdbGTFtagExonParentGene"
        },
        {
          "id": "#STAR.sjdbOverhang",
          "default": 124
        },
        {
          "id": "#STAR.sjdbScore"
        },
        {
          "source": [
            "#sjdbGTFfile"
          ],
          "id": "#STAR.sjdbGTFfile"
        },
        {
          "id": "#STAR.clip3pNbases"
        },
        {
          "id": "#STAR.clip5pNbases"
        },
        {
          "id": "#STAR.clip3pAdapterSeq"
        },
        {
          "id": "#STAR.clip3pAdapterMMp"
        },
        {
          "id": "#STAR.clip3pAfterAdapterNbases"
        },
        {
          "id": "#STAR.chimOutType"
        },
        {
          "source": [
            "#genome"
          ],
          "id": "#STAR.genome"
        },
        {
          "id": "#STAR.limitSjdbInsertNsj"
        },
        {
          "id": "#STAR.quantTranscriptomeBan"
        },
        {
          "id": "#STAR.limitBAMsortRAM"
        }
      ],
      "id": "#STAR",
      "sbg:y": 395
    }
  ],
  "requirements": [],
  "sbg:project": "sarah/rd168-chern-wtx-align-and-qc",
  "sbg:modifiedBy": "sarah",
  "class": "Workflow",
  "sbg:canvas_zoom": 1,
  "sbg:sbgMaintained": false,
  "sbg:toolkit": "STAR",
  "sbg:latestRevision": 3,
  "sbg:contributors": [
    "sarah"
  ],
  "sbg:revision": 3,
  "sbg:createdOn": 1471538983,
  "sbg:modifiedOn": 1472219720,
  "sbg:id": "sarah/rd168-chern-wtx-align-and-qc/rna-seq-alignment-star/3",
  "sbg:categories": [
    "Alignment",
    "RNA"
  ]
}
